import {
  slide
} from "./chunk-NEPPIW22.js";
import "./chunk-X7HCJ7ZS.js";
import "./chunk-MKB22NMU.js";
import {
  autoUpdate,
  platform
} from "./chunk-2HTL3BWD.js";
import {
  arrow,
  computePosition,
  flip,
  hide,
  limitShift,
  offset,
  shift,
  size
} from "./chunk-UYPSBRTO.js";
import {
  writable
} from "./chunk-JGA5J4NP.js";
import "./chunk-VFRMSNTO.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_iframe_resize_listener,
  add_location,
  add_render_callback,
  append_hydration_dev,
  assign,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  prop_dev,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_dynamic_element_data,
  set_store_value,
  set_style,
  set_svg_attributes,
  space,
  src_url_equal,
  stop_propagation,
  svg_element,
  tick,
  transition_in,
  transition_out,
  update_slot_base,
  validate_dynamic_element,
  validate_slots,
  validate_store,
  validate_void_dynamic_element
} from "./chunk-7P4LZH3B.js";
import "./chunk-CECPARVN.js";
import "./chunk-E3EO7R6B.js";

// node_modules/radix-svelte/dist/internal/helpers/useActions.js
function useActions(node, actions) {
  const actionReturns = [];
  if (actions) {
    for (let i = 0; i < actions.length; i++) {
      const actionEntry = actions[i];
      const action = Array.isArray(actionEntry) ? actionEntry[0] : actionEntry;
      if (Array.isArray(actionEntry) && actionEntry.length > 1) {
        actionReturns.push(action(node, actionEntry[1]));
      } else {
        actionReturns.push(action(node));
      }
    }
  }
  return {
    update(actions2) {
      if ((actions2 && actions2.length || 0) != actionReturns.length) {
        throw new Error("You must not change the length of an actions array.");
      }
      if (!actions2)
        return;
      for (let i = 0; i < actions2.length; i++) {
        const returnEntry = actionReturns[i];
        if (returnEntry && returnEntry.update) {
          const actionEntry = actions2[i];
          if (Array.isArray(actionEntry) && actionEntry.length > 1) {
            returnEntry.update(actionEntry[1]);
          } else {
            returnEntry.update();
          }
        }
      }
    },
    destroy() {
      for (let i = 0; i < actionReturns.length; i++) {
        const returnEntry = actionReturns[i];
        if (returnEntry && returnEntry.destroy) {
          returnEntry.destroy();
        }
      }
    }
  };
}

// node_modules/radix-svelte/dist/components/AspectRatio/root.svelte
var file = "node_modules/radix-svelte/dist/components/AspectRatio/root.svelte";
function create_fragment(ctx) {
  let div1;
  let div0;
  let div0_style_value;
  let useActions_action;
  let style_padding_bottom = `${100 / /*ratio*/
  ctx[0]}%`;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div0_levels = [
    {
      style: div0_style_value = /*$$props*/
      ctx[1].style
    },
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div0_levels.length; i += 1) {
    div_data = assign(div_data, div0_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { "data-radix-aspect-ratio-wrapper": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { style: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div0, div_data);
      set_style(div0, "position", `absolute`);
      set_style(div0, "top", `0`);
      set_style(div0, "right", `0`);
      set_style(div0, "bottom", `0`);
      set_style(div0, "left", `0`);
      add_location(div0, file, 12, 1, 275);
      attr_dev(div1, "data-radix-aspect-ratio-wrapper", "");
      set_style(div1, "position", `relative`);
      set_style(div1, "width", `100%`);
      set_style(div1, "padding-bottom", style_padding_bottom);
      add_location(div1, file, 6, 0, 145);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          div0,
          /*$$restProps*/
          ctx[2].use
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div0, div_data = get_spread_update(div0_levels, [
        (!current || dirty & /*$$props*/
        2 && div0_style_value !== (div0_style_value = /*$$props*/
        ctx2[1].style)) && { style: div0_style_value },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      4)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[2].use
        );
      set_style(div0, "position", `absolute`);
      set_style(div0, "top", `0`);
      set_style(div0, "right", `0`);
      set_style(div0, "bottom", `0`);
      set_style(div0, "left", `0`);
      if (dirty & /*ratio*/
      1 && style_padding_bottom !== (style_padding_bottom = `${100 / /*ratio*/
      ctx2[0]}%`)) {
        set_style(div1, "padding-bottom", style_padding_bottom);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["ratio"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, ["default"]);
  let { ratio = 1 / 1 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ratio" in $$new_props)
      $$invalidate(0, ratio = $$new_props.ratio);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ useActions, ratio });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), $$new_props));
    if ("ratio" in $$props)
      $$invalidate(0, ratio = $$new_props.ratio);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [ratio, $$props, $$restProps, $$scope, slots];
}
var Root = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { ratio: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment.name
    });
  }
  get ratio() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ratio(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var root_default = Root;

// node_modules/radix-svelte/dist/components/AspectRatio/index.js
var AspectRatio = {
  Root: root_default
};

// node_modules/radix-svelte/dist/internal/helpers/array.js
function next(array, index, loop = true) {
  if (index === array.length - 1) {
    return loop ? array[0] : array[index];
  }
  return array[index + 1];
}
function prev(array, index, loop = true) {
  if (index === 0) {
    return loop ? array[array.length - 1] : array[index];
  }
  return array[index - 1];
}

// node_modules/radix-svelte/dist/internal/helpers/uniqueContext.js
function uniqueContext() {
  const key = Symbol();
  return {
    getContext: () => getContext(key),
    setContext: (value) => setContext(key, value)
  };
}

// node_modules/radix-svelte/dist/internal/helpers/collectionContext.js
function collectionContext() {
  const initialContext = uniqueContext();
  const setContext20 = () => {
    const store = writable([]);
    initialContext.setContext(store);
    return store;
  };
  return { setContext: setContext20, getContext: initialContext.getContext };
}
var useCollection = (node, args) => {
  if (!args)
    throw new Error("No args provided");
  const { collection: store } = args;
  store.update((nodes) => [...nodes, node]);
  const unsubscribe = store.subscribe((nodes) => {
    var _a;
    (_a = args == null ? void 0 : args.onIndexChange) == null ? void 0 : _a.call(args, nodes.indexOf(node));
  });
  return {
    destroy: () => {
      unsubscribe();
      store.update((nodes) => nodes.filter((n) => n !== node));
    }
  };
};

// node_modules/radix-svelte/dist/internal/helpers/dom.js
function focus(element2) {
  if (isHTMLElement(element2)) {
    element2.focus();
  } else if (typeof element2 === "string") {
    const el = document.querySelector(element2);
    if (isHTMLElement(el)) {
      el.focus();
    }
  }
}
function isHTMLElement(element2) {
  return element2 instanceof HTMLElement;
}

// node_modules/radix-svelte/dist/internal/helpers/event.js
function handleAndDispatchCustomEvent(name, handler, detail) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { cancelable: true, detail });
  if (handler)
    target.addEventListener(name, handler, { once: true });
  target.dispatchEvent(event);
}

// node_modules/radix-svelte/dist/internal/helpers/id.js
var count = 0;
function generateId() {
  return `radix-svelte-${count++}`;
}

// node_modules/radix-svelte/dist/internal/helpers/numbers.js
function clamp(value, [min, max]) {
  return Math.min(max, Math.max(min, value));
}

// node_modules/radix-svelte/dist/internal/helpers/object.js
function objectEntries(obj) {
  return Object.entries(obj);
}
function joinKeys(...objects) {
  return [...new Set(objects.flatMap(Object.keys))];
}

// node_modules/radix-svelte/dist/internal/helpers/reactiveContext.js
function reactiveContext(defaults16) {
  const initialContext = uniqueContext();
  const setContext20 = (setters) => {
    const keys = joinKeys(defaults16 ?? {}, setters ?? {});
    const store = writable(keys.reduce((acc, key) => {
      if ((defaults16 == null ? void 0 : defaults16[key]) !== void 0) {
        acc[key] = defaults16[key];
      }
      return acc;
    }, {}));
    const update = (updater) => {
      store.update((prev2) => {
        const newState = updater(prev2);
        const keys2 = joinKeys(defaults16 ?? {}, newState ?? {});
        const withDefaults = keys2.reduce((acc, key) => {
          if (newState[key] === void 0 && (defaults16 == null ? void 0 : defaults16[key]) !== void 0) {
            acc[key] = defaults16[key];
          } else {
            acc[key] = newState[key];
          }
          return acc;
        }, {});
        objectEntries(withDefaults).forEach(([key, value]) => {
          if (setters) {
            const setter = key in setters ? setters[key] : void 0;
            setter == null ? void 0 : setter(value);
          }
        });
        return withDefaults;
      });
    };
    const set = (v) => {
      update(() => v);
    };
    const contextStore = {
      ...store,
      set,
      update
    };
    initialContext.setContext(contextStore);
    return contextStore;
  };
  return { ...initialContext, setContext: setContext20, defaults: defaults16 };
}

// node_modules/radix-svelte/dist/internal/helpers/style.js
function styleToString(style) {
  return Object.keys(style).reduce((str, key) => {
    if (style[key] === void 0)
      return str;
    return str + `${key}:${style[key]};`;
  }, "");
}

// node_modules/radix-svelte/dist/internal/helpers/browser.js
var isBrowser = typeof window !== "undefined";

// node_modules/radix-svelte/dist/internal/helpers/platform.js
var isDom = () => typeof window !== "undefined";
function getPlatform() {
  const agent = navigator.userAgentData;
  return (agent == null ? void 0 : agent.platform) ?? navigator.platform;
}
var pt = (v) => isDom() && v.test(getPlatform());
var isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;
var isMac = () => pt(/^Mac/) && !isTouchDevice();
var isApple = () => pt(/mac|iphone|ipad|ipod/i);
var isIos = () => isApple() && !isMac();

// node_modules/radix-svelte/dist/components/Accordion/root.svelte
var file2 = "node_modules/radix-svelte/dist/components/Accordion/root.svelte";
function create_fragment2(ctx) {
  let div;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[0],
    { "data-radix-accordion-root": "" }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "data-radix-accordion-root": true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file2, 21, 0, 787);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          div,
          /*$$restProps*/
          ctx[0].use
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        1 && /*$$restProps*/
        ctx2[0],
        { "data-radix-accordion-root": "" }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      1)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[0].use
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var { getContext: getContext2, setContext: setContext2, defaults } = reactiveContext({
  type: "single",
  value: null,
  disabled: false
});
var getRootCtx = getContext2;
var triggerCollectionContext = collectionContext();
var getTriggerCollection = triggerCollectionContext.getContext;
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = ["type", "value", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, ["default"]);
  let { type = defaults == null ? void 0 : defaults.type } = $$props;
  let { value = defaults == null ? void 0 : defaults.value } = $$props;
  let { disabled = defaults == null ? void 0 : defaults.disabled } = $$props;
  const ctx = setContext2({ value: (v) => $$invalidate(1, value = v) });
  triggerCollectionContext.setContext();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("type" in $$new_props)
      $$invalidate(2, type = $$new_props.type);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    collectionContext,
    reactiveContext,
    useActions,
    getContext: getContext2,
    setContext: setContext2,
    defaults,
    getRootCtx,
    triggerCollectionContext,
    getTriggerCollection,
    type,
    value,
    disabled,
    ctx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("type" in $$props)
      $$invalidate(2, type = $$new_props.type);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*type, value, disabled*/
    14) {
      $:
        ctx.set({ type, value, disabled });
    }
  };
  return [$$restProps, value, type, disabled, $$scope, slots];
}
var Root2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { type: 2, value: 1, disabled: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment2.name
    });
  }
  get type() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var root_default2 = Root2;

// node_modules/radix-svelte/dist/components/Accordion/item.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(15:0) <Collapsible.Root open={isOpen} disabled={$rootCtx.disabled} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let collapsible_root;
  let current;
  const collapsible_root_spread_levels = [
    { open: (
      /*isOpen*/
      ctx[1]
    ) },
    { disabled: (
      /*$rootCtx*/
      ctx[0].disabled
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let collapsible_root_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < collapsible_root_spread_levels.length; i += 1) {
    collapsible_root_props = assign(collapsible_root_props, collapsible_root_spread_levels[i]);
  }
  collapsible_root = new Collapsible.Root({
    props: collapsible_root_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(collapsible_root.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(collapsible_root.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(collapsible_root, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const collapsible_root_changes = dirty & /*isOpen, $rootCtx, $$restProps*/
      11 ? get_spread_update(collapsible_root_spread_levels, [
        dirty & /*isOpen*/
        2 && { open: (
          /*isOpen*/
          ctx2[1]
        ) },
        dirty & /*$rootCtx*/
        1 && { disabled: (
          /*$rootCtx*/
          ctx2[0].disabled
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      64) {
        collapsible_root_changes.$$scope = { dirty, ctx: ctx2 };
      }
      collapsible_root.$set(collapsible_root_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(collapsible_root.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(collapsible_root.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(collapsible_root, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var { getContext: getContext3, setContext: setContext3 } = reactiveContext();
var getItemContext = getContext3;
function instance3($$self, $$props, $$invalidate) {
  let isOpen;
  const omit_props_names = ["value"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Item", slots, ["default"]);
  let { value } = $$props;
  const rootCtx = getRootCtx();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value2) => $$invalidate(0, $rootCtx = value2));
  const itemCtx = setContext3();
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<Item> was created without expected prop 'value'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(4, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    reactiveContext,
    getContext: getContext3,
    setContext: setContext3,
    getItemContext,
    Collapsible,
    getRootCtx,
    value,
    rootCtx,
    itemCtx,
    isOpen,
    $rootCtx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(4, value = $$new_props.value);
    if ("isOpen" in $$props)
      $$invalidate(1, isOpen = $$new_props.isOpen);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$rootCtx, value*/
    17) {
      $:
        $$invalidate(1, isOpen = Array.isArray($rootCtx.value) ? $rootCtx.value.includes(value) : $rootCtx.value === value);
    }
    if ($$self.$$.dirty & /*value*/
    16) {
      $:
        itemCtx.set({ value });
    }
  };
  return [$rootCtx, isOpen, rootCtx, $$restProps, value, slots, $$scope];
}
var Item = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { value: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Item",
      options,
      id: create_fragment3.name
    });
  }
  get value() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var item_default = Item;

// node_modules/radix-svelte/dist/components/Accordion/header.svelte
var file3 = "node_modules/radix-svelte/dist/components/Accordion/header.svelte";
function create_fragment4(ctx) {
  let h3;
  let h3_data_state_value;
  let h3_data_disabled_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let h3_levels = [
    {
      "data-state": h3_data_state_value = /*isOpen*/
      ctx[1] ? "open" : "closed"
    },
    {
      "data-disabled": h3_data_disabled_value = /*$rootCtx*/
      ctx[0].disabled ? "true" : void 0
    },
    /*$$restProps*/
    ctx[4]
  ];
  let h3_data = {};
  for (let i = 0; i < h3_levels.length; i += 1) {
    h3_data = assign(h3_data, h3_levels[i]);
  }
  const block = {
    c: function create() {
      h3 = element("h3");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h3 = claim_element(nodes, "H3", {
        "data-state": true,
        "data-disabled": true
      });
      var h3_nodes = children(h3);
      if (default_slot)
        default_slot.l(h3_nodes);
      h3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(h3, h3_data);
      add_location(h3, file3, 11, 0, 410);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h3, anchor);
      if (default_slot) {
        default_slot.m(h3, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          h3,
          /*$$restProps*/
          ctx[4].use
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h3, h3_data = get_spread_update(h3_levels, [
        (!current || dirty & /*isOpen*/
        2 && h3_data_state_value !== (h3_data_state_value = /*isOpen*/
        ctx2[1] ? "open" : "closed")) && { "data-state": h3_data_state_value },
        (!current || dirty & /*$rootCtx*/
        1 && h3_data_disabled_value !== (h3_data_disabled_value = /*$rootCtx*/
        ctx2[0].disabled ? "true" : void 0)) && { "data-disabled": h3_data_disabled_value },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      16)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[4].use
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h3);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let isOpen;
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $itemCtx;
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Header", slots, ["default"]);
  const rootCtx = getRootCtx();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value) => $$invalidate(0, $rootCtx = value));
  const itemCtx = getItemContext();
  validate_store(itemCtx, "itemCtx");
  component_subscribe($$self, itemCtx, (value) => $$invalidate(5, $itemCtx = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useActions,
    getItemContext,
    getRootCtx,
    rootCtx,
    itemCtx,
    isOpen,
    $itemCtx,
    $rootCtx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("isOpen" in $$props)
      $$invalidate(1, isOpen = $$new_props.isOpen);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$rootCtx, $itemCtx*/
    33) {
      $:
        $$invalidate(1, isOpen = Array.isArray($rootCtx.value) ? $rootCtx.value.includes($itemCtx.value) : $rootCtx.value === $itemCtx.value);
    }
  };
  return [$rootCtx, isOpen, rootCtx, itemCtx, $$restProps, $itemCtx, $$scope, slots];
}
var Header = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Header",
      options,
      id: create_fragment4.name
    });
  }
};
var header_default = Header;

// node_modules/radix-svelte/dist/components/Collapsible/root.svelte
var file4 = "node_modules/radix-svelte/dist/components/Collapsible/root.svelte";
function create_fragment5(ctx) {
  let div;
  let div_data_state_value;
  let div_data_disabled_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    {
      "data-state": div_data_state_value = /*open*/
      ctx[0] ? "open" : "closed"
    },
    {
      "data-disabled": div_data_disabled_value = /*disabled*/
      ctx[1] ? "true" : void 0
    },
    { "data-radix-collapsible-root": "" },
    /*$$restProps*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        "data-state": true,
        "data-disabled": true,
        "data-radix-collapsible-root": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file4, 17, 0, 529);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          div,
          /*use*/
          ctx[2] ?? []
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*open*/
        1 && div_data_state_value !== (div_data_state_value = /*open*/
        ctx2[0] ? "open" : "closed")) && { "data-state": div_data_state_value },
        (!current || dirty & /*disabled*/
        2 && div_data_disabled_value !== (div_data_disabled_value = /*disabled*/
        ctx2[1] ? "true" : void 0)) && { "data-disabled": div_data_disabled_value },
        { "data-radix-collapsible-root": "" },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      4)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[2] ?? []
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var defaults2 = { open: false, disabled: false };
var { getContext: getContext4, setContext: setContext4 } = reactiveContext(defaults2);
var getCollapsibleRootContext = getContext4;
function instance5($$self, $$props, $$invalidate) {
  const omit_props_names = ["open", "disabled", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, ["default"]);
  let { open = defaults2.open } = $$props;
  let { disabled = defaults2.disabled } = $$props;
  let { use = [] } = $$props;
  const ctx = setContext4({ open: (v) => $$invalidate(0, open = v) });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    reactiveContext,
    defaults: defaults2,
    getContext: getContext4,
    setContext: setContext4,
    getCollapsibleRootContext,
    useActions,
    open,
    disabled,
    use,
    ctx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open, disabled*/
    3) {
      $:
        ctx.set({ open, disabled });
    }
  };
  return [open, disabled, use, $$restProps, $$scope, slots];
}
var Root3 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { open: 0, disabled: 1, use: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment5.name
    });
  }
  get open() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var root_default3 = Root3;

// node_modules/radix-svelte/dist/components/Collapsible/content.svelte
var file5 = "node_modules/radix-svelte/dist/components/Collapsible/content.svelte";
function create_if_block(ctx) {
  let div;
  let div_data_state_value;
  let div_data_disabled_value;
  let useActions_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[3],
    {
      "data-state": div_data_state_value = /*$ctx*/
      ctx[1].open ? "open" : "closed"
    },
    {
      "data-disabled": div_data_disabled_value = /*$ctx*/
      ctx[1].disabled ? "true" : void 0
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        "data-state": true,
        "data-disabled": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file5, 23, 1, 598);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          div,
          /*$$restProps*/
          ctx[3].use
        ));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx[3],
        (!current || dirty & /*$ctx*/
        2 && div_data_state_value !== (div_data_state_value = /*$ctx*/
        ctx[1].open ? "open" : "closed")) && { "data-state": div_data_state_value },
        (!current || dirty & /*$ctx*/
        2 && div_data_disabled_value !== (div_data_disabled_value = /*$ctx*/
        ctx[1].disabled ? "true" : void 0)) && { "data-disabled": div_data_disabled_value }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      8)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx[3].use
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(
              div,
              slide,
              /*transitionParams*/
              ctx[0],
              true
            );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(
            div,
            slide,
            /*transitionParams*/
            ctx[0],
            false
          );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(23:0) {#if $ctx.open}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$ctx*/
    ctx[1].open && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$ctx*/
        ctx2[1].open
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$ctx*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let transitionParams;
  const omit_props_names = ["transition"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $ctx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Content", slots, ["default"]);
  let { transition = void 0 } = $$props;
  const ctx = getCollapsibleRootContext();
  validate_store(ctx, "ctx");
  component_subscribe($$self, ctx, (value) => $$invalidate(1, $ctx = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("transition" in $$new_props)
      $$invalidate(4, transition = $$new_props.transition);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    slide,
    getCollapsibleRootContext,
    useActions,
    transition,
    ctx,
    transitionParams,
    $ctx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("transition" in $$props)
      $$invalidate(4, transition = $$new_props.transition);
    if ("transitionParams" in $$props)
      $$invalidate(0, transitionParams = $$new_props.transitionParams);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*transition*/
    16) {
      $:
        $$invalidate(0, transitionParams = function getParams2() {
          if (!transition) {
            return { duration: 0 };
          }
          let transitionObj = typeof transition === "object" ? transition : {};
          return { duration: 300, ...transitionObj };
        }());
    }
  };
  return [transitionParams, $ctx, ctx, $$restProps, transition, $$scope, slots];
}
var Content = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { transition: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Content",
      options,
      id: create_fragment6.name
    });
  }
  get transition() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var content_default = Content;

// node_modules/radix-svelte/dist/components/Collapsible/trigger.svelte
var file6 = "node_modules/radix-svelte/dist/components/Collapsible/trigger.svelte";
function create_fragment7(ctx) {
  let button;
  let button_data_state_value;
  let button_data_disabled_value;
  let button_disabled_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let button_levels = [
    /*$$restProps*/
    ctx[3],
    {
      "data-state": button_data_state_value = /*$ctx*/
      ctx[0].open ? "open" : "closed"
    },
    {
      "data-disabled": button_data_disabled_value = /*$ctx*/
      ctx[0].disabled ? "true" : void 0
    },
    {
      disabled: button_disabled_value = /*$ctx*/
      ctx[0].disabled
    },
    { type: "button" }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        "data-state": true,
        "data-disabled": true,
        type: true
      });
      var button_nodes = children(button);
      if (default_slot)
        default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file6, 10, 0, 323);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            button,
            /*$$restProps*/
            ctx[3].use
          )),
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            /*keydown_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*$ctx*/
        1 && button_data_state_value !== (button_data_state_value = /*$ctx*/
        ctx2[0].open ? "open" : "closed")) && { "data-state": button_data_state_value },
        (!current || dirty & /*$ctx*/
        1 && button_data_disabled_value !== (button_data_disabled_value = /*$ctx*/
        ctx2[0].disabled ? "true" : void 0)) && {
          "data-disabled": button_data_disabled_value
        },
        (!current || dirty & /*$ctx*/
        1 && button_disabled_value !== (button_disabled_value = /*$ctx*/
        ctx2[0].disabled)) && { disabled: button_disabled_value },
        { type: "button" }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      8)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[3].use
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $ctx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Trigger", slots, ["default"]);
  const ctx = getCollapsibleRootContext();
  validate_store(ctx, "ctx");
  component_subscribe($$self, ctx, (value) => $$invalidate(0, $ctx = value));
  const dispatch = createEventDispatcher();
  function keydown_handler2(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler = () => {
    set_store_value(ctx, $ctx.open = !$ctx.open, $ctx);
    dispatch("change", $ctx.open);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useActions,
    createEventDispatcher,
    getCollapsibleRootContext,
    ctx,
    dispatch,
    $ctx
  });
  return [
    $ctx,
    ctx,
    dispatch,
    $$restProps,
    $$scope,
    slots,
    keydown_handler2,
    click_handler
  ];
}
var Trigger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Trigger",
      options,
      id: create_fragment7.name
    });
  }
};
var trigger_default = Trigger;

// node_modules/radix-svelte/dist/components/Collapsible/index.js
var Collapsible = {
  Content: content_default,
  Trigger: trigger_default,
  Root: root_default3
};

// node_modules/radix-svelte/dist/components/Accordion/content.svelte
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(7:0) <Collapsible.Content {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let collapsible_content;
  let current;
  const collapsible_content_spread_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let collapsible_content_props = {
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < collapsible_content_spread_levels.length; i += 1) {
    collapsible_content_props = assign(collapsible_content_props, collapsible_content_spread_levels[i]);
  }
  collapsible_content = new Collapsible.Content({
    props: collapsible_content_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(collapsible_content.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(collapsible_content.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(collapsible_content, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const collapsible_content_changes = dirty & /*$$restProps*/
      1 ? get_spread_update(collapsible_content_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      4) {
        collapsible_content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      collapsible_content.$set(collapsible_content_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(collapsible_content.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(collapsible_content.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(collapsible_content, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Content", slots, ["default"]);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ Collapsible });
  return [$$restProps, slots, $$scope];
}
var Content2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Content",
      options,
      id: create_fragment8.name
    });
  }
};
var content_default2 = Content2;

// node_modules/radix-svelte/dist/components/Accordion/trigger.svelte
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(45:0) <Collapsible.Trigger  use={[   ...($$restProps.use ?? []),   [    useCollection,    {     collection: triggerCollection,     onIndexChange,    },   ],  ]}  on:change={(e) => {   const value = e.detail;   if ($rootCtx.type === 'single') {    $rootCtx.value = value ? $itemCtx.value : null;   } else {    const prevValue = Array.isArray($rootCtx.value) ? $rootCtx.value : [];    $rootCtx.value = value     ? [...prevValue, $itemCtx.value]     : prevValue.filter((v) => v !== $itemCtx.value);   }  }}  on:keydown={handleKeyDown}  {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let collapsible_trigger;
  let current;
  const collapsible_trigger_spread_levels = [
    {
      use: [
        .../*$$restProps*/
        ctx[7].use ?? [],
        [
          useCollection,
          {
            collection: (
              /*triggerCollection*/
              ctx[4]
            ),
            onIndexChange: (
              /*onIndexChange*/
              ctx[6]
            )
          }
        ]
      ]
    },
    /*$$restProps*/
    ctx[7]
  ];
  let collapsible_trigger_props = {
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < collapsible_trigger_spread_levels.length; i += 1) {
    collapsible_trigger_props = assign(collapsible_trigger_props, collapsible_trigger_spread_levels[i]);
  }
  collapsible_trigger = new Collapsible.Trigger({
    props: collapsible_trigger_props,
    $$inline: true
  });
  collapsible_trigger.$on(
    "change",
    /*change_handler*/
    ctx[9]
  );
  collapsible_trigger.$on(
    "keydown",
    /*handleKeyDown*/
    ctx[5]
  );
  const block = {
    c: function create() {
      create_component(collapsible_trigger.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(collapsible_trigger.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(collapsible_trigger, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const collapsible_trigger_changes = dirty & /*$$restProps, useCollection, triggerCollection, onIndexChange*/
      208 ? get_spread_update(collapsible_trigger_spread_levels, [
        {
          use: [
            .../*$$restProps*/
            ctx2[7].use ?? [],
            [
              useCollection,
              {
                collection: (
                  /*triggerCollection*/
                  ctx2[4]
                ),
                onIndexChange: (
                  /*onIndexChange*/
                  ctx2[6]
                )
              }
            ]
          ]
        },
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx2[7]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      1024) {
        collapsible_trigger_changes.$$scope = { dirty, ctx: ctx2 };
      }
      collapsible_trigger.$set(collapsible_trigger_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(collapsible_trigger.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(collapsible_trigger.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(collapsible_trigger, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $triggerCollection;
  let $rootCtx;
  let $itemCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Trigger", slots, ["default"]);
  const itemCtx = getItemContext();
  validate_store(itemCtx, "itemCtx");
  component_subscribe($$self, itemCtx, (value) => $$invalidate(1, $itemCtx = value));
  const rootCtx = getRootCtx();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value) => $$invalidate(0, $rootCtx = value));
  const triggerCollection2 = getTriggerCollection();
  validate_store(triggerCollection2, "triggerCollection");
  component_subscribe($$self, triggerCollection2, (value) => $$invalidate(12, $triggerCollection = value));
  let triggerIndex = 0;
  const handleKeyDown = (e) => {
    var _a, _b, _c, _d;
    switch (e.key) {
      case "ArrowDown": {
        e.preventDefault();
        e.stopPropagation();
        (_a = $triggerCollection[triggerIndex + 1]) == null ? void 0 : _a.focus();
        break;
      }
      case "ArrowUp": {
        e.preventDefault();
        e.stopPropagation();
        (_b = $triggerCollection[triggerIndex - 1]) == null ? void 0 : _b.focus();
        break;
      }
      case "Home": {
        e.preventDefault();
        e.stopPropagation();
        (_c = $triggerCollection[0]) == null ? void 0 : _c.focus();
        break;
      }
      case "End": {
        e.preventDefault();
        e.stopPropagation();
        (_d = $triggerCollection.at(-1)) == null ? void 0 : _d.focus();
        break;
      }
    }
  };
  function onIndexChange(index) {
    triggerIndex = index;
  }
  const change_handler = (e) => {
    const value = e.detail;
    if ($rootCtx.type === "single") {
      set_store_value(rootCtx, $rootCtx.value = value ? $itemCtx.value : null, $rootCtx);
    } else {
      const prevValue = Array.isArray($rootCtx.value) ? $rootCtx.value : [];
      set_store_value(
        rootCtx,
        $rootCtx.value = value ? [...prevValue, $itemCtx.value] : prevValue.filter((v) => v !== $itemCtx.value),
        $rootCtx
      );
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useCollection,
    Collapsible,
    getItemContext,
    getRootCtx,
    getTriggerCollection,
    itemCtx,
    rootCtx,
    triggerCollection: triggerCollection2,
    triggerIndex,
    handleKeyDown,
    onIndexChange,
    $triggerCollection,
    $rootCtx,
    $itemCtx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("triggerIndex" in $$props)
      triggerIndex = $$new_props.triggerIndex;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    $rootCtx,
    $itemCtx,
    itemCtx,
    rootCtx,
    triggerCollection2,
    handleKeyDown,
    onIndexChange,
    $$restProps,
    slots,
    change_handler,
    $$scope
  ];
}
var Trigger2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Trigger",
      options,
      id: create_fragment9.name
    });
  }
};
var trigger_default2 = Trigger2;

// node_modules/radix-svelte/dist/components/Accordion/index.js
var Accordion = {
  Root: root_default2,
  Item: item_default,
  Header: header_default,
  Content: content_default2,
  Trigger: trigger_default2
};

// node_modules/radix-svelte/dist/components/Checkbox/root.svelte
var file7 = "node_modules/radix-svelte/dist/components/Checkbox/root.svelte";
function create_fragment10(ctx) {
  let button;
  let t;
  let input;
  let input_tabindex_value;
  let input_checked_value;
  let button_aria_checked_value;
  let button_data_state_value;
  let button_data_disabled_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let button_levels = [
    { type: "button" },
    { role: "checkbox" },
    {
      "aria-checked": button_aria_checked_value = isIndeterminate(
        /*checked*/
        ctx[0]
      ) ? "mixed" : (
        /*checked*/
        ctx[0]
      )
    },
    { "aria-required": (
      /*required*/
      ctx[2]
    ) },
    {
      "data-state": button_data_state_value = getState(
        /*$ctx*/
        ctx[5].checked
      )
    },
    {
      "data-disabled": button_data_disabled_value = /*disabled*/
      ctx[1] ? "" : void 0
    },
    { disabled: (
      /*disabled*/
      ctx[1]
    ) },
    { value: (
      /*value*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[7]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      t = space();
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        role: true,
        "aria-checked": true,
        "aria-required": true,
        "data-state": true,
        "data-disabled": true
      });
      var button_nodes = children(button);
      if (default_slot)
        default_slot.l(button_nodes);
      t = claim_space(button_nodes);
      input = claim_element(button_nodes, "INPUT", {
        type: true,
        "aria-hidden": true,
        tabindex: true,
        name: true
      });
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "checkbox");
      attr_dev(input, "aria-hidden", "true");
      input.hidden = true;
      attr_dev(input, "tabindex", input_tabindex_value = -1);
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[3]
      );
      input.value = /*value*/
      ctx[4];
      input.checked = input_checked_value = isIndeterminate(
        /*checked*/
        ctx[0]
      ) ? false : (
        /*checked*/
        ctx[0]
      );
      input.required = /*required*/
      ctx[2];
      input.disabled = /*disabled*/
      ctx[1];
      set_style(input, "position", `absolute`);
      set_style(input, "pointer-events", `none`);
      set_style(input, "opacity", `0`);
      set_style(input, "margin", `0`);
      set_style(input, "transform", `translateX(-100%)`);
      add_location(input, file7, 51, 1, 1401);
      set_attributes(button, button_data);
      add_location(button, file7, 25, 0, 772);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      append_hydration_dev(button, t);
      append_hydration_dev(button, input);
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", stop_propagation(
            /*click_handler*/
            ctx[10]
          ), false, false, true, false),
          listen_dev(button, "keydown", keydown_handler, false, false, false, false),
          action_destroyer(useActions_action = useActions.call(
            null,
            button,
            /*$$restProps*/
            ctx[7].use
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*name*/
      8) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*value*/
      16) {
        prop_dev(
          input,
          "value",
          /*value*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*checked*/
      1 && input_checked_value !== (input_checked_value = isIndeterminate(
        /*checked*/
        ctx2[0]
      ) ? false : (
        /*checked*/
        ctx2[0]
      ))) {
        prop_dev(input, "checked", input_checked_value);
      }
      if (!current || dirty & /*required*/
      4) {
        prop_dev(
          input,
          "required",
          /*required*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*disabled*/
      2) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[1]
        );
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        { role: "checkbox" },
        (!current || dirty & /*checked*/
        1 && button_aria_checked_value !== (button_aria_checked_value = isIndeterminate(
          /*checked*/
          ctx2[0]
        ) ? "mixed" : (
          /*checked*/
          ctx2[0]
        ))) && {
          "aria-checked": button_aria_checked_value
        },
        (!current || dirty & /*required*/
        4) && { "aria-required": (
          /*required*/
          ctx2[2]
        ) },
        (!current || dirty & /*$ctx*/
        32 && button_data_state_value !== (button_data_state_value = getState(
          /*$ctx*/
          ctx2[5].checked
        ))) && { "data-state": button_data_state_value },
        (!current || dirty & /*disabled*/
        2 && button_data_disabled_value !== (button_data_disabled_value = /*disabled*/
        ctx2[1] ? "" : void 0)) && {
          "data-disabled": button_data_disabled_value
        },
        (!current || dirty & /*disabled*/
        2) && { disabled: (
          /*disabled*/
          ctx2[1]
        ) },
        (!current || dirty & /*value*/
        16) && { value: (
          /*value*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      128)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[7].use
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var defaults3 = { checked: false, disabled: false };
var { getContext: getContext5, setContext: setContext5 } = reactiveContext(defaults3);
var getRootContext = getContext5;
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
var keydown_handler = (event) => {
  if (event.key === "Enter")
    event.preventDefault();
};
function instance10($$self, $$props, $$invalidate) {
  const omit_props_names = ["checked", "disabled", "required", "name", "value"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $ctx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, ["default"]);
  let { checked = defaults3.checked } = $$props;
  let { disabled = defaults3.disabled } = $$props;
  let { required = false } = $$props;
  let { name = "" } = $$props;
  let { value = "" } = $$props;
  const ctx = setContext5();
  validate_store(ctx, "ctx");
  component_subscribe($$self, ctx, (value2) => $$invalidate(5, $ctx = value2));
  const click_handler = () => {
    if (isIndeterminate(checked)) {
      $$invalidate(0, checked = true);
    } else {
      $$invalidate(0, checked = !checked);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("required" in $$new_props)
      $$invalidate(2, required = $$new_props.required);
    if ("name" in $$new_props)
      $$invalidate(3, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(4, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    reactiveContext,
    useActions,
    defaults: defaults3,
    getContext: getContext5,
    setContext: setContext5,
    getRootContext,
    isIndeterminate,
    getState,
    checked,
    disabled,
    required,
    name,
    value,
    ctx,
    $ctx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("required" in $$props)
      $$invalidate(2, required = $$new_props.required);
    if ("name" in $$props)
      $$invalidate(3, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(4, value = $$new_props.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*checked, disabled*/
    3) {
      $:
        ctx.set({ checked, disabled });
    }
  };
  return [
    checked,
    disabled,
    required,
    name,
    value,
    $ctx,
    ctx,
    $$restProps,
    $$scope,
    slots,
    click_handler
  ];
}
var Root4 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      checked: 0,
      disabled: 1,
      required: 2,
      name: 3,
      value: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment10.name
    });
  }
  get checked() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var root_default4 = Root4;

// node_modules/radix-svelte/dist/components/Checkbox/indicator.svelte
var file8 = "node_modules/radix-svelte/dist/components/Checkbox/indicator.svelte";
function create_if_block2(ctx) {
  let span;
  let span_data_state_value;
  let span_data_disabled_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let span_levels = [
    /*$$restProps*/
    ctx[2],
    {
      "data-state": span_data_state_value = getState(
        /*$ctx*/
        ctx[0].checked
      )
    },
    {
      "data-disabled": span_data_disabled_value = /*$ctx*/
      ctx[0].disabled ? "" : void 0
    }
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        "data-state": true,
        "data-disabled": true
      });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      set_style(span, "pointer-events", `none`);
      add_location(span, file8, 9, 1, 311);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          span,
          /*$$restProps*/
          ctx[2].use
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*$ctx*/
        1 && span_data_state_value !== (span_data_state_value = getState(
          /*$ctx*/
          ctx2[0].checked
        ))) && { "data-state": span_data_state_value },
        (!current || dirty & /*$ctx*/
        1 && span_data_disabled_value !== (span_data_disabled_value = /*$ctx*/
        ctx2[0].disabled ? "" : void 0)) && {
          "data-disabled": span_data_disabled_value
        }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      4)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[2].use
        );
      set_style(span, "pointer-events", `none`);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(9:0) {#if isIndeterminate($ctx.checked) || !!$ctx.checked}",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let show_if = isIndeterminate(
    /*$ctx*/
    ctx[0].checked
  ) || !!/*$ctx*/
  ctx[0].checked;
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block2(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$ctx*/
      1)
        show_if = isIndeterminate(
          /*$ctx*/
          ctx2[0].checked
        ) || !!/*$ctx*/
        ctx2[0].checked;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$ctx*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $ctx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Indicator", slots, ["default"]);
  const ctx = getRootContext();
  validate_store(ctx, "ctx");
  component_subscribe($$self, ctx, (value) => $$invalidate(0, $ctx = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useActions,
    getRootContext,
    getState,
    isIndeterminate,
    ctx,
    $ctx
  });
  return [$ctx, ctx, $$restProps, $$scope, slots];
}
var Indicator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Indicator",
      options,
      id: create_fragment11.name
    });
  }
};
var indicator_default = Indicator;

// node_modules/radix-svelte/dist/components/Checkbox/index.js
var Checkbox = {
  Root: root_default4,
  Indicator: indicator_default
};

// node_modules/radix-svelte/dist/components/Separator/root.svelte
var file9 = "node_modules/radix-svelte/dist/components/Separator/root.svelte";
function create_fragment12(ctx) {
  let div;
  let div_role_value;
  let useActions_action;
  let mounted;
  let dispose;
  let div_levels = [
    {
      "data-orientation": (
        /*orientation*/
        ctx[0]
      )
    },
    {
      role: div_role_value = /*decorative*/
      ctx[1] ? "none" : "separator"
    },
    /*$$restProps*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "data-orientation": true, role: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file9, 8, 0, 199);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          div,
          /*use*/
          ctx[2] ?? []
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*orientation*/
        1 && {
          "data-orientation": (
            /*orientation*/
            ctx2[0]
          )
        },
        dirty & /*decorative*/
        2 && div_role_value !== (div_role_value = /*decorative*/
        ctx2[1] ? "none" : "separator") && { role: div_role_value },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      4)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[2] ?? []
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  const omit_props_names = ["orientation", "decorative", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, []);
  let { orientation = "horizontal" } = $$props;
  let { decorative = false } = $$props;
  let { use = [] } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("orientation" in $$new_props)
      $$invalidate(0, orientation = $$new_props.orientation);
    if ("decorative" in $$new_props)
      $$invalidate(1, decorative = $$new_props.decorative);
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
  };
  $$self.$capture_state = () => ({ useActions, orientation, decorative, use });
  $$self.$inject_state = ($$new_props) => {
    if ("orientation" in $$props)
      $$invalidate(0, orientation = $$new_props.orientation);
    if ("decorative" in $$props)
      $$invalidate(1, decorative = $$new_props.decorative);
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [orientation, decorative, use, $$restProps];
}
var Root5 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { orientation: 0, decorative: 1, use: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment12.name
    });
  }
  get orientation() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get decorative() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decorative(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var root_default5 = Root5;

// node_modules/radix-svelte/dist/components/Separator/index.js
var Separator = {
  Root: root_default5
};

// node_modules/radix-svelte/dist/components/Slider/internal/utils.js
var PAGE_KEYS = ["PageUp", "PageDown"];
var ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var BACK_KEYS = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
};
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function getDecimalCount(value) {
  return (String(value).split(".")[1] || "").length;
}
function roundValue(value, decimalCount) {
  const rounder = Math.pow(10, decimalCount);
  return Math.round(value * rounder) / rounder;
}
function convertValueToPercentage(value, min, max) {
  const maxSteps = max - min;
  const percentPerStep = 100 / maxSteps;
  const percentage = percentPerStep * (value - min);
  return clamp(percentage, [0, 100]);
}
function getNextSortedValues(prevValues = [], nextValue, atIndex) {
  const nextValues = [...prevValues];
  nextValues[atIndex] = nextValue;
  return nextValues.sort((a, b) => a - b);
}
function getClosestValueIndex(values, nextValue) {
  if (values.length === 1)
    return 0;
  const distances = values.map((value) => Math.abs(value - nextValue));
  const closestDistance = Math.min(...distances);
  return distances.indexOf(closestDistance);
}
function getStepsBetweenValues(values) {
  return values.slice(0, -1).map((value, index) => values[index + 1] - value);
}
function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
  if (minStepsBetweenValues > 0) {
    const stepsBetweenValues = getStepsBetweenValues(values);
    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
    return actualMinStepsBetweenValues >= minStepsBetweenValues;
  }
  return true;
}

// node_modules/radix-svelte/dist/components/Slider/internal/SliderImpl.svelte
var file10 = "node_modules/radix-svelte/dist/components/Slider/internal/SliderImpl.svelte";
function create_fragment13(ctx) {
  let span;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let span_levels = [
    /*$$restProps*/
    ctx[4]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file10, 8, 0, 291);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      ctx[7](span);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            span,
            "keydown",
            /*keydown_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            span,
            "pointerdown",
            /*pointerdown_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            span,
            "pointermove",
            /*pointermove_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            span,
            "pointerup",
            /*pointerup_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [dirty & /*$$restProps*/
      16 && /*$$restProps*/
      ctx2[4]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  const omit_props_names = ["element"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $thumbCollection;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SliderImpl", slots, ["default"]);
  let { element: element2 } = $$props;
  const dispatch = createEventDispatcher();
  const thumbCollection = getThumbCollectionContext();
  validate_store(thumbCollection, "thumbCollection");
  component_subscribe($$self, thumbCollection, (value) => $$invalidate(1, $thumbCollection = value));
  $$self.$$.on_mount.push(function() {
    if (element2 === void 0 && !("element" in $$props || $$self.$$.bound[$$self.$$.props["element"]])) {
      console.warn("<SliderImpl> was created without expected prop 'element'");
    }
  });
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  const keydown_handler2 = (event) => {
    if (event.key === "Home") {
      dispatch("homeKeyDown", event);
      event.preventDefault();
    } else if (event.key === "End") {
      dispatch("endKeyDown", event);
      event.preventDefault();
    } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {
      dispatch("stepKeyDown", event);
      event.preventDefault();
    }
  };
  const pointerdown_handler = (event) => {
    const target = event.currentTarget;
    target.setPointerCapture(event.pointerId);
    event.preventDefault();
    if ($thumbCollection.includes(target)) {
      target.focus();
    } else {
      dispatch("slideStart", event);
    }
  };
  const pointermove_handler = (event) => {
    const target = event.currentTarget;
    if (target.hasPointerCapture(event.pointerId))
      dispatch("slideMove", event);
  };
  const pointerup_handler = (event) => {
    const target = event.currentTarget;
    if (target.hasPointerCapture(event.pointerId)) {
      target.releasePointerCapture(event.pointerId);
      dispatch("slideEnd", event);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getThumbCollectionContext,
    createEventDispatcher,
    ARROW_KEYS,
    PAGE_KEYS,
    element: element2,
    dispatch,
    thumbCollection,
    $thumbCollection
  });
  $$self.$inject_state = ($$new_props) => {
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    $thumbCollection,
    dispatch,
    thumbCollection,
    $$restProps,
    $$scope,
    slots,
    span_binding,
    keydown_handler2,
    pointerdown_handler,
    pointermove_handler,
    pointerup_handler
  ];
}
var SliderImpl = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { element: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SliderImpl",
      options,
      id: create_fragment13.name
    });
  }
  get element() {
    throw new Error("<SliderImpl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<SliderImpl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SliderImpl_default = SliderImpl;

// node_modules/radix-svelte/dist/components/Slider/internal/SliderHorizontal.svelte
function create_default_slot4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: `(33:0) <SliderImpl  bind:element={slider}  style=\\"{$$restProps.style}; --radix-slider-thumb-transform: translateX(-50%)\\"  on:slideStart={(event) => {   const value = getValueFromPointer(event.detail.clientX);   dispatch('slideStart', { value });  }}  on:slideMove={(event) => {   const value = getValueFromPointer(event.detail.clientX);   dispatch('slideMove', { value });  }}  on:slideEnd={() => {   rect = undefined;   dispatch('slideEnd');  }}  on:stepKeyDown={(event) => {   const slideDirection = isSlidingFromLeft ? 'from-left' : 'from-right';   const isBackKey = BACK_KEYS[slideDirection].includes(event.detail.key);   dispatch('stepKeyDown', { event: event.detail, direction: isBackKey ? -1 : 1 });  }}  on:homeKeyDown  on:endKeyDown  {...$$restProps} >`,
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let sliderimpl;
  let updating_element;
  let current;
  const sliderimpl_spread_levels = [
    {
      style: (
        /*$$restProps*/
        ctx[6].style + "; --radix-slider-thumb-transform: translateX(-50%)"
      )
    },
    /*$$restProps*/
    ctx[6]
  ];
  function sliderimpl_element_binding(value) {
    ctx[13](value);
  }
  let sliderimpl_props = {
    $$slots: { default: [create_default_slot4] },
    $$scope: { ctx }
  };
  for (let i = 0; i < sliderimpl_spread_levels.length; i += 1) {
    sliderimpl_props = assign(sliderimpl_props, sliderimpl_spread_levels[i]);
  }
  if (
    /*slider*/
    ctx[1] !== void 0
  ) {
    sliderimpl_props.element = /*slider*/
    ctx[1];
  }
  sliderimpl = new SliderImpl_default({ props: sliderimpl_props, $$inline: true });
  binding_callbacks.push(() => bind(sliderimpl, "element", sliderimpl_element_binding));
  sliderimpl.$on(
    "slideStart",
    /*slideStart_handler*/
    ctx[14]
  );
  sliderimpl.$on(
    "slideMove",
    /*slideMove_handler*/
    ctx[15]
  );
  sliderimpl.$on(
    "slideEnd",
    /*slideEnd_handler*/
    ctx[16]
  );
  sliderimpl.$on(
    "stepKeyDown",
    /*stepKeyDown_handler*/
    ctx[17]
  );
  sliderimpl.$on(
    "homeKeyDown",
    /*homeKeyDown_handler*/
    ctx[18]
  );
  sliderimpl.$on(
    "endKeyDown",
    /*endKeyDown_handler*/
    ctx[19]
  );
  const block = {
    c: function create() {
      create_component(sliderimpl.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(sliderimpl.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(sliderimpl, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const sliderimpl_changes = dirty & /*$$restProps*/
      64 ? get_spread_update(sliderimpl_spread_levels, [
        {
          style: (
            /*$$restProps*/
            ctx2[6].style + "; --radix-slider-thumb-transform: translateX(-50%)"
          )
        },
        get_spread_object(
          /*$$restProps*/
          ctx2[6]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      1048576) {
        sliderimpl_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty & /*slider*/
      2) {
        updating_element = true;
        sliderimpl_changes.element = /*slider*/
        ctx2[1];
        add_flush_callback(() => updating_element = false);
      }
      sliderimpl.$set(sliderimpl_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(sliderimpl.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(sliderimpl.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(sliderimpl, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let isDirectionLTR;
  let isSlidingFromLeft;
  const omit_props_names = ["min", "max", "dir", "inverted"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $orientation;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SliderHorizontal", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let slider;
  let { min } = $$props;
  let { max } = $$props;
  let { dir } = $$props;
  let { inverted } = $$props;
  const orientation = getOrientationContext();
  validate_store(orientation, "orientation");
  component_subscribe($$self, orientation, (value) => $$invalidate(21, $orientation = value));
  let rect;
  function getValueFromPointer(pointerPosition) {
    if (!rect)
      $$invalidate(2, rect = slider.getBoundingClientRect());
    if (!rect)
      return 0;
    const input = [0, rect.width];
    const output = isSlidingFromLeft ? [min, max] : [max, min];
    const value = linearScale(input, output);
    return value(pointerPosition - rect.left);
  }
  $$self.$$.on_mount.push(function() {
    if (min === void 0 && !("min" in $$props || $$self.$$.bound[$$self.$$.props["min"]])) {
      console.warn("<SliderHorizontal> was created without expected prop 'min'");
    }
    if (max === void 0 && !("max" in $$props || $$self.$$.bound[$$self.$$.props["max"]])) {
      console.warn("<SliderHorizontal> was created without expected prop 'max'");
    }
    if (dir === void 0 && !("dir" in $$props || $$self.$$.bound[$$self.$$.props["dir"]])) {
      console.warn("<SliderHorizontal> was created without expected prop 'dir'");
    }
    if (inverted === void 0 && !("inverted" in $$props || $$self.$$.bound[$$self.$$.props["inverted"]])) {
      console.warn("<SliderHorizontal> was created without expected prop 'inverted'");
    }
  });
  function sliderimpl_element_binding(value) {
    slider = value;
    $$invalidate(1, slider);
  }
  const slideStart_handler = (event) => {
    const value = getValueFromPointer(event.detail.clientX);
    dispatch("slideStart", { value });
  };
  const slideMove_handler = (event) => {
    const value = getValueFromPointer(event.detail.clientX);
    dispatch("slideMove", { value });
  };
  const slideEnd_handler = () => {
    $$invalidate(2, rect = void 0);
    dispatch("slideEnd");
  };
  const stepKeyDown_handler = (event) => {
    const slideDirection = isSlidingFromLeft ? "from-left" : "from-right";
    const isBackKey = BACK_KEYS[slideDirection].includes(event.detail.key);
    dispatch("stepKeyDown", {
      event: event.detail,
      direction: isBackKey ? -1 : 1
    });
  };
  function homeKeyDown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function endKeyDown_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("min" in $$new_props)
      $$invalidate(7, min = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(8, max = $$new_props.max);
    if ("dir" in $$new_props)
      $$invalidate(9, dir = $$new_props.dir);
    if ("inverted" in $$new_props)
      $$invalidate(10, inverted = $$new_props.inverted);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    getOrientationContext,
    SliderImpl: SliderImpl_default,
    BACK_KEYS,
    linearScale,
    dispatch,
    slider,
    min,
    max,
    dir,
    inverted,
    orientation,
    rect,
    getValueFromPointer,
    isSlidingFromLeft,
    isDirectionLTR,
    $orientation
  });
  $$self.$inject_state = ($$new_props) => {
    if ("slider" in $$props)
      $$invalidate(1, slider = $$new_props.slider);
    if ("min" in $$props)
      $$invalidate(7, min = $$new_props.min);
    if ("max" in $$props)
      $$invalidate(8, max = $$new_props.max);
    if ("dir" in $$props)
      $$invalidate(9, dir = $$new_props.dir);
    if ("inverted" in $$props)
      $$invalidate(10, inverted = $$new_props.inverted);
    if ("rect" in $$props)
      $$invalidate(2, rect = $$new_props.rect);
    if ("isSlidingFromLeft" in $$props)
      $$invalidate(0, isSlidingFromLeft = $$new_props.isSlidingFromLeft);
    if ("isDirectionLTR" in $$props)
      $$invalidate(11, isDirectionLTR = $$new_props.isDirectionLTR);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*dir*/
    512) {
      $:
        $$invalidate(11, isDirectionLTR = dir === "ltr");
    }
    if ($$self.$$.dirty & /*isDirectionLTR, inverted*/
    3072) {
      $:
        $$invalidate(0, isSlidingFromLeft = isDirectionLTR && !inverted || !isDirectionLTR && inverted);
    }
    if ($$self.$$.dirty & /*isSlidingFromLeft*/
    1) {
      $:
        set_store_value(
          orientation,
          $orientation = {
            startEdge: isSlidingFromLeft ? "left" : "right",
            endEdge: isSlidingFromLeft ? "right" : "left",
            size: "width",
            direction: isSlidingFromLeft ? 1 : -1
          },
          $orientation
        );
    }
  };
  return [
    isSlidingFromLeft,
    slider,
    rect,
    dispatch,
    orientation,
    getValueFromPointer,
    $$restProps,
    min,
    max,
    dir,
    inverted,
    isDirectionLTR,
    slots,
    sliderimpl_element_binding,
    slideStart_handler,
    slideMove_handler,
    slideEnd_handler,
    stepKeyDown_handler,
    homeKeyDown_handler,
    endKeyDown_handler,
    $$scope
  ];
}
var SliderHorizontal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { min: 7, max: 8, dir: 9, inverted: 10 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SliderHorizontal",
      options,
      id: create_fragment14.name
    });
  }
  get min() {
    throw new Error("<SliderHorizontal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<SliderHorizontal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<SliderHorizontal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<SliderHorizontal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dir() {
    throw new Error("<SliderHorizontal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dir(value) {
    throw new Error("<SliderHorizontal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inverted() {
    throw new Error("<SliderHorizontal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inverted(value) {
    throw new Error("<SliderHorizontal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SliderHorizontal_default = SliderHorizontal;

// node_modules/radix-svelte/dist/components/Slider/internal/SliderVertical.svelte
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: `(31:0) <SliderImpl  bind:element={slider}  style=\\"{$$restProps.style}; --radix-slider-thumb-transform: translateY(-50%)\\"  on:slideStart={(event) => {   const value = getValueFromPointer(event.detail.clientY);   dispatch('slideStart', { value });  }}  on:slideMove={(event) => {   const value = getValueFromPointer(event.detail.clientY);   dispatch('slideMove', { value });  }}  on:slideEnd={() => {   rect = undefined;   dispatch('slideEnd');  }}  on:stepKeyDown={(event) => {   const slideDirection = isSlidingFromBottom ? 'from-bottom' : 'from-top';   const isBackKey = BACK_KEYS[slideDirection].includes(event.detail.key);   dispatch('stepKeyDown', { event: event.detail, direction: isBackKey ? -1 : 1 });  }}  on:homeKeyDown  on:endKeyDown  {...$$restProps} >`,
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let sliderimpl;
  let updating_element;
  let current;
  const sliderimpl_spread_levels = [
    {
      style: (
        /*$$restProps*/
        ctx[6].style + "; --radix-slider-thumb-transform: translateY(-50%)"
      )
    },
    /*$$restProps*/
    ctx[6]
  ];
  function sliderimpl_element_binding(value) {
    ctx[11](value);
  }
  let sliderimpl_props = {
    $$slots: { default: [create_default_slot5] },
    $$scope: { ctx }
  };
  for (let i = 0; i < sliderimpl_spread_levels.length; i += 1) {
    sliderimpl_props = assign(sliderimpl_props, sliderimpl_spread_levels[i]);
  }
  if (
    /*slider*/
    ctx[1] !== void 0
  ) {
    sliderimpl_props.element = /*slider*/
    ctx[1];
  }
  sliderimpl = new SliderImpl_default({ props: sliderimpl_props, $$inline: true });
  binding_callbacks.push(() => bind(sliderimpl, "element", sliderimpl_element_binding));
  sliderimpl.$on(
    "slideStart",
    /*slideStart_handler*/
    ctx[12]
  );
  sliderimpl.$on(
    "slideMove",
    /*slideMove_handler*/
    ctx[13]
  );
  sliderimpl.$on(
    "slideEnd",
    /*slideEnd_handler*/
    ctx[14]
  );
  sliderimpl.$on(
    "stepKeyDown",
    /*stepKeyDown_handler*/
    ctx[15]
  );
  sliderimpl.$on(
    "homeKeyDown",
    /*homeKeyDown_handler*/
    ctx[16]
  );
  sliderimpl.$on(
    "endKeyDown",
    /*endKeyDown_handler*/
    ctx[17]
  );
  const block = {
    c: function create() {
      create_component(sliderimpl.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(sliderimpl.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(sliderimpl, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const sliderimpl_changes = dirty & /*$$restProps*/
      64 ? get_spread_update(sliderimpl_spread_levels, [
        {
          style: (
            /*$$restProps*/
            ctx2[6].style + "; --radix-slider-thumb-transform: translateY(-50%)"
          )
        },
        get_spread_object(
          /*$$restProps*/
          ctx2[6]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      262144) {
        sliderimpl_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_element && dirty & /*slider*/
      2) {
        updating_element = true;
        sliderimpl_changes.element = /*slider*/
        ctx2[1];
        add_flush_callback(() => updating_element = false);
      }
      sliderimpl.$set(sliderimpl_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(sliderimpl.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(sliderimpl.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(sliderimpl, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let isSlidingFromBottom;
  const omit_props_names = ["min", "max", "inverted"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $orientation;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SliderVertical", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let slider;
  let { min } = $$props;
  let { max } = $$props;
  let { inverted } = $$props;
  const orientation = getOrientationContext();
  validate_store(orientation, "orientation");
  component_subscribe($$self, orientation, (value) => $$invalidate(19, $orientation = value));
  let rect;
  function getValueFromPointer(pointerPosition) {
    if (!rect)
      $$invalidate(2, rect = slider.getBoundingClientRect());
    if (!rect)
      return 0;
    const input = [0, rect.height];
    const output = isSlidingFromBottom ? [max, min] : [min, max];
    const value = linearScale(input, output);
    return value(pointerPosition - rect.top);
  }
  $$self.$$.on_mount.push(function() {
    if (min === void 0 && !("min" in $$props || $$self.$$.bound[$$self.$$.props["min"]])) {
      console.warn("<SliderVertical> was created without expected prop 'min'");
    }
    if (max === void 0 && !("max" in $$props || $$self.$$.bound[$$self.$$.props["max"]])) {
      console.warn("<SliderVertical> was created without expected prop 'max'");
    }
    if (inverted === void 0 && !("inverted" in $$props || $$self.$$.bound[$$self.$$.props["inverted"]])) {
      console.warn("<SliderVertical> was created without expected prop 'inverted'");
    }
  });
  function sliderimpl_element_binding(value) {
    slider = value;
    $$invalidate(1, slider);
  }
  const slideStart_handler = (event) => {
    const value = getValueFromPointer(event.detail.clientY);
    dispatch("slideStart", { value });
  };
  const slideMove_handler = (event) => {
    const value = getValueFromPointer(event.detail.clientY);
    dispatch("slideMove", { value });
  };
  const slideEnd_handler = () => {
    $$invalidate(2, rect = void 0);
    dispatch("slideEnd");
  };
  const stepKeyDown_handler = (event) => {
    const slideDirection = isSlidingFromBottom ? "from-bottom" : "from-top";
    const isBackKey = BACK_KEYS[slideDirection].includes(event.detail.key);
    dispatch("stepKeyDown", {
      event: event.detail,
      direction: isBackKey ? -1 : 1
    });
  };
  function homeKeyDown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function endKeyDown_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("min" in $$new_props)
      $$invalidate(7, min = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(8, max = $$new_props.max);
    if ("inverted" in $$new_props)
      $$invalidate(9, inverted = $$new_props.inverted);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    getOrientationContext,
    SliderImpl: SliderImpl_default,
    BACK_KEYS,
    linearScale,
    dispatch,
    slider,
    min,
    max,
    inverted,
    orientation,
    rect,
    getValueFromPointer,
    isSlidingFromBottom,
    $orientation
  });
  $$self.$inject_state = ($$new_props) => {
    if ("slider" in $$props)
      $$invalidate(1, slider = $$new_props.slider);
    if ("min" in $$props)
      $$invalidate(7, min = $$new_props.min);
    if ("max" in $$props)
      $$invalidate(8, max = $$new_props.max);
    if ("inverted" in $$props)
      $$invalidate(9, inverted = $$new_props.inverted);
    if ("rect" in $$props)
      $$invalidate(2, rect = $$new_props.rect);
    if ("isSlidingFromBottom" in $$props)
      $$invalidate(0, isSlidingFromBottom = $$new_props.isSlidingFromBottom);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*inverted*/
    512) {
      $:
        $$invalidate(0, isSlidingFromBottom = !inverted);
    }
    if ($$self.$$.dirty & /*isSlidingFromBottom*/
    1) {
      $:
        set_store_value(
          orientation,
          $orientation = {
            startEdge: isSlidingFromBottom ? "bottom" : "top",
            endEdge: isSlidingFromBottom ? "top" : "bottom",
            size: "height",
            direction: isSlidingFromBottom ? -1 : 1
          },
          $orientation
        );
    }
  };
  return [
    isSlidingFromBottom,
    slider,
    rect,
    dispatch,
    orientation,
    getValueFromPointer,
    $$restProps,
    min,
    max,
    inverted,
    slots,
    sliderimpl_element_binding,
    slideStart_handler,
    slideMove_handler,
    slideEnd_handler,
    stepKeyDown_handler,
    homeKeyDown_handler,
    endKeyDown_handler,
    $$scope
  ];
}
var SliderVertical = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { min: 7, max: 8, inverted: 9 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SliderVertical",
      options,
      id: create_fragment15.name
    });
  }
  get min() {
    throw new Error("<SliderVertical>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<SliderVertical>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<SliderVertical>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<SliderVertical>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inverted() {
    throw new Error("<SliderVertical>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inverted(value) {
    throw new Error("<SliderVertical>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SliderVertical_default = SliderVertical;

// node_modules/radix-svelte/dist/components/Slider/root.svelte
var file11 = "node_modules/radix-svelte/dist/components/Slider/root.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list[i];
  return child_ctx;
}
function create_default_slot6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(87:0) <svelte:component  this={SliderOrientation}  {...$$restProps}  dir={dir ?? 'ltr'}  min={$ctx.min}  max={$ctx.max}  {inverted}  aria-disabled={disabled}  data-disabled={disabled ? '' : undefined}  data-orientation={orientation}  on:pointerDown={() => {   if (!disabled) valuesBeforeSlideStart = $ctx.values;  }}  on:slideStart={({ detail }) => {   if (disabled) return;   const { value } = detail;   const closestIndex = getClosestValueIndex($ctx.values, value);   updateValues(value, closestIndex);   $thumbComponents.at($ctx.valueIndexToChange)?.focus();  }}  on:slideMove={({ detail }) => {   if (disabled) return;   const { value } = detail;   updateValues(value, $ctx.valueIndexToChange);  }}  on:slideEnd={() => {   if (disabled) return;   const prevValue = valuesBeforeSlideStart[$ctx.valueIndexToChange];   const nextValue = $ctx.values[$ctx.valueIndexToChange];   const hasChanged = nextValue !== prevValue;   if (hasChanged) onValueCommit($ctx.values);  }}  on:homeKeyDown={() => !disabled && updateValues($ctx.min, 0, { commit: true })}  on:endKeyDown={() =>   !disabled && updateValues($ctx.max, $ctx.values.length - 1, { commit: true })}  on:stepKeyDown={({ detail }) => {   if (!disabled) {    const { event, direction: stepDirection } = detail;    const isPageKey = PAGE_KEYS.includes(event.key);    const isSkipKey = isPageKey || (event.shiftKey && ARROW_KEYS.includes(event.key));    const multiplier = isSkipKey ? 10 : 1;    const atIndex = $ctx.valueIndexToChange;    const value = $ctx.values[atIndex];    const stepInDirection = step * multiplier * stepDirection;    updateValues(value + stepInDirection, atIndex, { commit: true });   }  }}>",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let input;
  let input_name_value;
  let input_value_value;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true, name: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "hidden");
      attr_dev(input, "name", input_name_value = /*name*/
      ctx[6] ? (
        /*name*/
        ctx[6] + /*$ctx*/
        (ctx[9].values.length > 1 ? "[]" : "")
      ) : void 0);
      input.value = input_value_value = /*value*/
      ctx[0];
      set_style(input, "display", `none`);
      add_location(input, file11, 135, 1, 4863);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*name, $ctx*/
      576 && input_name_value !== (input_name_value = /*name*/
      ctx2[6] ? (
        /*name*/
        ctx2[6] + /*$ctx*/
        (ctx2[9].values.length > 1 ? "[]" : "")
      ) : void 0)) {
        attr_dev(input, "name", input_name_value);
      }
      if (dirty[0] & /*$ctx*/
      512 && input_value_value !== (input_value_value = /*value*/
      ctx2[0])) {
        prop_dev(input, "value", input_value_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(135:0) {#each $ctx.values as value}",
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let switch_instance;
  let t;
  let each_1_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*$$restProps*/
    ctx[15],
    { dir: (
      /*dir*/
      ctx[3] ?? "ltr"
    ) },
    { min: (
      /*$ctx*/
      ctx[9].min
    ) },
    { max: (
      /*$ctx*/
      ctx[9].max
    ) },
    { inverted: (
      /*inverted*/
      ctx[2]
    ) },
    { "aria-disabled": (
      /*disabled*/
      ctx[4]
    ) },
    {
      "data-disabled": (
        /*disabled*/
        ctx[4] ? "" : void 0
      )
    },
    {
      "data-orientation": (
        /*orientation*/
        ctx[5]
      )
    }
  ];
  var switch_value = (
    /*SliderOrientation*/
    ctx[8]
  );
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot6] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    switch_instance.$on(
      "pointerDown",
      /*pointerDown_handler*/
      ctx[20]
    );
    switch_instance.$on(
      "slideStart",
      /*slideStart_handler*/
      ctx[21]
    );
    switch_instance.$on(
      "slideMove",
      /*slideMove_handler*/
      ctx[22]
    );
    switch_instance.$on(
      "slideEnd",
      /*slideEnd_handler*/
      ctx[23]
    );
    switch_instance.$on(
      "homeKeyDown",
      /*homeKeyDown_handler*/
      ctx[24]
    );
    switch_instance.$on(
      "endKeyDown",
      /*endKeyDown_handler*/
      ctx[25]
    );
    switch_instance.$on(
      "stepKeyDown",
      /*stepKeyDown_handler*/
      ctx[26]
    );
  }
  let each_value = ensure_array_like_dev(
    /*$ctx*/
    ctx[9].values
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      t = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, t, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty[0] & /*$$restProps, dir, $ctx, inverted, disabled, orientation*/
      33340 ? get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*$$restProps*/
        32768 && get_spread_object(
          /*$$restProps*/
          ctx2[15]
        ),
        dirty[0] & /*dir*/
        8 && { dir: (
          /*dir*/
          ctx2[3] ?? "ltr"
        ) },
        dirty[0] & /*$ctx*/
        512 && { min: (
          /*$ctx*/
          ctx2[9].min
        ) },
        dirty[0] & /*$ctx*/
        512 && { max: (
          /*$ctx*/
          ctx2[9].max
        ) },
        dirty[0] & /*inverted*/
        4 && { inverted: (
          /*inverted*/
          ctx2[2]
        ) },
        dirty[0] & /*disabled*/
        16 && { "aria-disabled": (
          /*disabled*/
          ctx2[4]
        ) },
        dirty[0] & /*disabled*/
        16 && {
          "data-disabled": (
            /*disabled*/
            ctx2[4] ? "" : void 0
          )
        },
        dirty[0] & /*orientation*/
        32 && {
          "data-orientation": (
            /*orientation*/
            ctx2[5]
          )
        }
      ]) : {};
      if (dirty[0] & /*$$scope*/
      134217728) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty[0] & /*SliderOrientation*/
      256 && switch_value !== (switch_value = /*SliderOrientation*/
      ctx2[8])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          switch_instance.$on(
            "pointerDown",
            /*pointerDown_handler*/
            ctx2[20]
          );
          switch_instance.$on(
            "slideStart",
            /*slideStart_handler*/
            ctx2[21]
          );
          switch_instance.$on(
            "slideMove",
            /*slideMove_handler*/
            ctx2[22]
          );
          switch_instance.$on(
            "slideEnd",
            /*slideEnd_handler*/
            ctx2[23]
          );
          switch_instance.$on(
            "homeKeyDown",
            /*homeKeyDown_handler*/
            ctx2[24]
          );
          switch_instance.$on(
            "endKeyDown",
            /*endKeyDown_handler*/
            ctx2[25]
          );
          switch_instance.$on(
            "stepKeyDown",
            /*stepKeyDown_handler*/
            ctx2[26]
          );
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, t.parentNode, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      if (dirty[0] & /*name, $ctx*/
      576) {
        each_value = ensure_array_like_dev(
          /*$ctx*/
          ctx2[9].values
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(each_1_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var { getContext: getContext6, setContext: setContext6, defaults: defaults4 } = reactiveContext({
  min: 0,
  max: 100,
  disabled: false,
  orientation: "horizontal",
  valueIndexToChange: -1
});
var getRootContext2 = getContext6;
var orientationContext = uniqueContext();
var getOrientationContext = orientationContext.getContext;
var thumbCollectionContext = collectionContext();
var getThumbCollectionContext = thumbCollectionContext.getContext;
function instance16($$self, $$props, $$invalidate) {
  let SliderOrientation;
  const omit_props_names = [
    "step",
    "minStepsBetweenThumbs",
    "inverted",
    "dir",
    "min",
    "max",
    "disabled",
    "orientation",
    "value",
    "name"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $ctx;
  let $thumbComponents;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, ["default"]);
  let { step = 1 } = $$props;
  let { minStepsBetweenThumbs = 0 } = $$props;
  let { inverted = false } = $$props;
  let { dir = "ltr" } = $$props;
  let { min = defaults4 == null ? void 0 : defaults4.min } = $$props;
  let { max = defaults4 == null ? void 0 : defaults4.max } = $$props;
  let { disabled = defaults4 == null ? void 0 : defaults4.disabled } = $$props;
  let { orientation = defaults4 == null ? void 0 : defaults4.orientation } = $$props;
  let { value = [min ?? 0] } = $$props;
  let { name = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  const ctx = setContext6({
    values: (v) => {
      if (Array.isArray(value)) {
        $$invalidate(0, value = Array.isArray(v) ? v : [v]);
      } else {
        $$invalidate(0, value = Array.isArray(v) ? v[0] : v);
      }
      onChange(v);
    }
  });
  validate_store(ctx, "ctx");
  component_subscribe($$self, ctx, (value2) => $$invalidate(9, $ctx = value2));
  orientationContext.setContext(writable({
    startEdge: "left",
    endEdge: "right",
    size: "width",
    direction: 1
  }));
  const thumbComponents = thumbCollectionContext.setContext();
  validate_store(thumbComponents, "thumbComponents");
  component_subscribe($$self, thumbComponents, (value2) => $$invalidate(10, $thumbComponents = value2));
  let valuesBeforeSlideStart = $ctx.values;
  function updateValues(value2, atIndex, { commit } = { commit: false }) {
    const decimalCount = getDecimalCount(step);
    const snapToStep = roundValue(Math.round((value2 - $ctx.min) / step) * step + $ctx.min, decimalCount);
    const nextValue = clamp(snapToStep, [$ctx.min, $ctx.max]);
    const prevValues = $ctx.values;
    const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);
    if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {
      set_store_value(ctx, $ctx.valueIndexToChange = nextValues.indexOf(nextValue), $ctx);
      const hasChanged = String(nextValues) !== String(prevValues);
      if (hasChanged && commit)
        onValueCommit(nextValues);
      if (hasChanged) {
        set_store_value(ctx, $ctx.values = nextValues, $ctx);
      }
    }
  }
  function onValueCommit(values) {
    dispatch("valueCommit", values);
  }
  function onChange(nextValues) {
    dispatch("valueChange", nextValues);
  }
  const pointerDown_handler = () => {
    if (!disabled)
      $$invalidate(7, valuesBeforeSlideStart = $ctx.values);
  };
  const slideStart_handler = ({ detail }) => {
    var _a;
    if (disabled)
      return;
    const { value: value2 } = detail;
    const closestIndex = getClosestValueIndex($ctx.values, value2);
    updateValues(value2, closestIndex);
    (_a = $thumbComponents.at($ctx.valueIndexToChange)) == null ? void 0 : _a.focus();
  };
  const slideMove_handler = ({ detail }) => {
    if (disabled)
      return;
    const { value: value2 } = detail;
    updateValues(value2, $ctx.valueIndexToChange);
  };
  const slideEnd_handler = () => {
    if (disabled)
      return;
    const prevValue = valuesBeforeSlideStart[$ctx.valueIndexToChange];
    const nextValue = $ctx.values[$ctx.valueIndexToChange];
    const hasChanged = nextValue !== prevValue;
    if (hasChanged)
      onValueCommit($ctx.values);
  };
  const homeKeyDown_handler = () => !disabled && updateValues($ctx.min, 0, { commit: true });
  const endKeyDown_handler = () => !disabled && updateValues($ctx.max, $ctx.values.length - 1, { commit: true });
  const stepKeyDown_handler = ({ detail }) => {
    if (!disabled) {
      const { event, direction: stepDirection } = detail;
      const isPageKey = PAGE_KEYS.includes(event.key);
      const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.includes(event.key);
      const multiplier = isSkipKey ? 10 : 1;
      const atIndex = $ctx.valueIndexToChange;
      const value2 = $ctx.values[atIndex];
      const stepInDirection = step * multiplier * stepDirection;
      updateValues(value2 + stepInDirection, atIndex, { commit: true });
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("step" in $$new_props)
      $$invalidate(1, step = $$new_props.step);
    if ("minStepsBetweenThumbs" in $$new_props)
      $$invalidate(16, minStepsBetweenThumbs = $$new_props.minStepsBetweenThumbs);
    if ("inverted" in $$new_props)
      $$invalidate(2, inverted = $$new_props.inverted);
    if ("dir" in $$new_props)
      $$invalidate(3, dir = $$new_props.dir);
    if ("min" in $$new_props)
      $$invalidate(17, min = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(18, max = $$new_props.max);
    if ("disabled" in $$new_props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("orientation" in $$new_props)
      $$invalidate(5, orientation = $$new_props.orientation);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("name" in $$new_props)
      $$invalidate(6, name = $$new_props.name);
    if ("$$scope" in $$new_props)
      $$invalidate(27, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    clamp,
    uniqueContext,
    createEventDispatcher,
    writable,
    getContext: getContext6,
    setContext: setContext6,
    defaults: defaults4,
    getRootContext: getRootContext2,
    orientationContext,
    getOrientationContext,
    thumbCollectionContext,
    getThumbCollectionContext,
    collectionContext,
    reactiveContext,
    SliderHorizontal: SliderHorizontal_default,
    SliderVertical: SliderVertical_default,
    ARROW_KEYS,
    PAGE_KEYS,
    getClosestValueIndex,
    getDecimalCount,
    getNextSortedValues,
    hasMinStepsBetweenValues,
    roundValue,
    step,
    minStepsBetweenThumbs,
    inverted,
    dir,
    min,
    max,
    disabled,
    orientation,
    value,
    name,
    dispatch,
    ctx,
    thumbComponents,
    valuesBeforeSlideStart,
    updateValues,
    onValueCommit,
    onChange,
    SliderOrientation,
    $ctx,
    $thumbComponents
  });
  $$self.$inject_state = ($$new_props) => {
    if ("step" in $$props)
      $$invalidate(1, step = $$new_props.step);
    if ("minStepsBetweenThumbs" in $$props)
      $$invalidate(16, minStepsBetweenThumbs = $$new_props.minStepsBetweenThumbs);
    if ("inverted" in $$props)
      $$invalidate(2, inverted = $$new_props.inverted);
    if ("dir" in $$props)
      $$invalidate(3, dir = $$new_props.dir);
    if ("min" in $$props)
      $$invalidate(17, min = $$new_props.min);
    if ("max" in $$props)
      $$invalidate(18, max = $$new_props.max);
    if ("disabled" in $$props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("orientation" in $$props)
      $$invalidate(5, orientation = $$new_props.orientation);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("name" in $$props)
      $$invalidate(6, name = $$new_props.name);
    if ("valuesBeforeSlideStart" in $$props)
      $$invalidate(7, valuesBeforeSlideStart = $$new_props.valuesBeforeSlideStart);
    if ("SliderOrientation" in $$props)
      $$invalidate(8, SliderOrientation = $$new_props.SliderOrientation);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*value, min, max, disabled, orientation*/
    393265) {
      $:
        ctx.update((prev2) => ({
          ...prev2,
          values: Array.isArray(value) ? value : [value ?? 0],
          min,
          max,
          disabled,
          orientation
        }));
    }
    if ($$self.$$.dirty[0] & /*orientation*/
    32) {
      $:
        $$invalidate(8, SliderOrientation = orientation === "horizontal" ? SliderHorizontal_default : SliderVertical_default);
    }
  };
  return [
    value,
    step,
    inverted,
    dir,
    disabled,
    orientation,
    name,
    valuesBeforeSlideStart,
    SliderOrientation,
    $ctx,
    $thumbComponents,
    ctx,
    thumbComponents,
    updateValues,
    onValueCommit,
    $$restProps,
    minStepsBetweenThumbs,
    min,
    max,
    slots,
    pointerDown_handler,
    slideStart_handler,
    slideMove_handler,
    slideEnd_handler,
    homeKeyDown_handler,
    endKeyDown_handler,
    stepKeyDown_handler,
    $$scope
  ];
}
var Root6 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance16,
      create_fragment16,
      safe_not_equal,
      {
        step: 1,
        minStepsBetweenThumbs: 16,
        inverted: 2,
        dir: 3,
        min: 17,
        max: 18,
        disabled: 4,
        orientation: 5,
        value: 0,
        name: 6
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment16.name
    });
  }
  get step() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minStepsBetweenThumbs() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minStepsBetweenThumbs(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inverted() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inverted(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dir() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dir(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orientation() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var root_default6 = Root6;

// node_modules/radix-svelte/dist/components/Slider/range.svelte
var file12 = "node_modules/radix-svelte/dist/components/Slider/range.svelte";
function create_fragment17(ctx) {
  let span;
  let span_data_orientation_value;
  let span_data_disabled_value;
  let span_style_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let span_levels = [
    /*$$restProps*/
    ctx[6],
    {
      "data-orientation": span_data_orientation_value = /*$rootCtx*/
      ctx[0].orientation
    },
    {
      "data-disabled": span_data_disabled_value = /*$rootCtx*/
      ctx[0].disabled ? "" : void 0
    },
    {
      style: span_style_value = /*$$restProps*/
      ctx[6].style + "; " + /*$orientation*/
      ctx[3].startEdge + ": " + /*offsetStart*/
      ctx[2] + "%; " + /*$orientation*/
      ctx[3].endEdge + ": " + /*offsetEnd*/
      ctx[1] + "%;"
    }
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        "data-orientation": true,
        "data-disabled": true,
        style: true
      });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file12, 16, 0, 623);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          span,
          /*$$restProps*/
          ctx[6].use
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        (!current || dirty & /*$rootCtx*/
        1 && span_data_orientation_value !== (span_data_orientation_value = /*$rootCtx*/
        ctx2[0].orientation)) && {
          "data-orientation": span_data_orientation_value
        },
        (!current || dirty & /*$rootCtx*/
        1 && span_data_disabled_value !== (span_data_disabled_value = /*$rootCtx*/
        ctx2[0].disabled ? "" : void 0)) && {
          "data-disabled": span_data_disabled_value
        },
        (!current || dirty & /*$$restProps, $orientation, offsetStart, offsetEnd*/
        78 && span_style_value !== (span_style_value = /*$$restProps*/
        ctx2[6].style + "; " + /*$orientation*/
        ctx2[3].startEdge + ": " + /*offsetStart*/
        ctx2[2] + "%; " + /*$orientation*/
        ctx2[3].endEdge + ": " + /*offsetEnd*/
        ctx2[1] + "%;")) && { style: span_style_value }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      64)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[6].use
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let valuesCount;
  let percentages;
  let offsetStart;
  let offsetEnd;
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let $orientation;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Range", slots, ["default"]);
  "use strict";
  const rootCtx = getRootContext2();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value) => $$invalidate(0, $rootCtx = value));
  const orientation = getOrientationContext();
  validate_store(orientation, "orientation");
  component_subscribe($$self, orientation, (value) => $$invalidate(3, $orientation = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useActions,
    convertValueToPercentage,
    getOrientationContext,
    getRootContext: getRootContext2,
    rootCtx,
    orientation,
    percentages,
    offsetEnd,
    valuesCount,
    offsetStart,
    $rootCtx,
    $orientation
  });
  $$self.$inject_state = ($$new_props) => {
    if ("percentages" in $$props)
      $$invalidate(7, percentages = $$new_props.percentages);
    if ("offsetEnd" in $$props)
      $$invalidate(1, offsetEnd = $$new_props.offsetEnd);
    if ("valuesCount" in $$props)
      $$invalidate(8, valuesCount = $$new_props.valuesCount);
    if ("offsetStart" in $$props)
      $$invalidate(2, offsetStart = $$new_props.offsetStart);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$rootCtx*/
    1) {
      $:
        $$invalidate(8, valuesCount = $rootCtx.values.length);
    }
    if ($$self.$$.dirty & /*$rootCtx*/
    1) {
      $:
        $$invalidate(7, percentages = $rootCtx.values.map((value) => {
          return convertValueToPercentage(value, $rootCtx.min, $rootCtx.max);
        }));
    }
    if ($$self.$$.dirty & /*valuesCount, percentages*/
    384) {
      $:
        $$invalidate(2, offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0);
    }
    if ($$self.$$.dirty & /*percentages*/
    128) {
      $:
        $$invalidate(1, offsetEnd = 100 - Math.max(...percentages));
    }
  };
  return [
    $rootCtx,
    offsetEnd,
    offsetStart,
    $orientation,
    rootCtx,
    orientation,
    $$restProps,
    percentages,
    valuesCount,
    $$scope,
    slots
  ];
}
var Range = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Range",
      options,
      id: create_fragment17.name
    });
  }
};
var range_default = Range;

// node_modules/radix-svelte/dist/components/Slider/thumb.svelte
var file13 = "node_modules/radix-svelte/dist/components/Slider/thumb.svelte";
function create_fragment18(ctx) {
  let span1;
  let span0;
  let span0_aria_label_value;
  let span0_aria_valuemin_value;
  let span0_aria_valuemax_value;
  let span0_aria_orientation_value;
  let span0_data_orientation_value;
  let span0_data_disabled_value;
  let span0_tabindex_value;
  let useCollection_action;
  let useActions_action;
  let span0_resize_listener;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  let span0_levels = [
    /*$$restProps*/
    ctx[10],
    { role: "slider" },
    {
      "aria-label": span0_aria_label_value = /*$$props*/
      ctx[11]["aria-label"] || /*label*/
      ctx[5]
    },
    {
      "aria-valuemin": span0_aria_valuemin_value = /*$rootCtx*/
      ctx[3].min
    },
    { "aria-valuenow": (
      /*value*/
      ctx[2]
    ) },
    {
      "aria-valuemax": span0_aria_valuemax_value = /*$rootCtx*/
      ctx[3].max
    },
    {
      "aria-orientation": span0_aria_orientation_value = /*$rootCtx*/
      ctx[3].orientation
    },
    {
      "data-orientation": span0_data_orientation_value = /*$rootCtx*/
      ctx[3].orientation
    },
    {
      "data-disabled": span0_data_disabled_value = /*$rootCtx*/
      ctx[3].disabled ? "" : void 0
    },
    {
      tabindex: span0_tabindex_value = /*$rootCtx*/
      ctx[3].disabled ? void 0 : 0
    }
  ];
  let span_data = {};
  for (let i = 0; i < span0_levels.length; i += 1) {
    span_data = assign(span_data, span0_levels[i]);
  }
  const block = {
    c: function create() {
      span1 = element("span");
      span0 = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span1 = claim_element(nodes, "SPAN", { style: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", {
        role: true,
        "aria-label": true,
        "aria-valuemin": true,
        "aria-valuenow": true,
        "aria-valuemax": true,
        "aria-orientation": true,
        "data-orientation": true,
        "data-disabled": true,
        tabindex: true
      });
      var span0_nodes = children(span0);
      if (default_slot)
        default_slot.l(span0_nodes);
      span0_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span0, span_data);
      add_render_callback(() => (
        /*span0_elementresize_handler*/
        ctx[18].call(span0)
      ));
      set_style(
        span0,
        "display",
        /*value*/
        ctx[2] === void 0 ? "none" : "inherit"
      );
      add_location(span0, file13, 46, 1, 1740);
      attr_dev(
        span1,
        "style",
        /*style*/
        ctx[4]
      );
      add_location(span1, file13, 45, 0, 1724);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, span0);
      if (default_slot) {
        default_slot.m(span0, null);
      }
      span0_resize_listener = add_iframe_resize_listener(
        span0,
        /*span0_elementresize_handler*/
        ctx[18].bind(span0)
      );
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useCollection_action = useCollection.call(null, span0, {
            collection: (
              /*thumbComponentsContext*/
              ctx[8]
            ),
            onIndexChange: (
              /*onIndexChange*/
              ctx[9]
            )
          })),
          action_destroyer(useActions_action = useActions.call(
            null,
            span0,
            /*$$restProps*/
            ctx[10].use
          )),
          listen_dev(
            span0,
            "focus",
            /*focus_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span0, span_data = get_spread_update(span0_levels, [
        dirty & /*$$restProps*/
        1024 && /*$$restProps*/
        ctx2[10],
        { role: "slider" },
        (!current || dirty & /*$$props, label*/
        2080 && span0_aria_label_value !== (span0_aria_label_value = /*$$props*/
        ctx2[11]["aria-label"] || /*label*/
        ctx2[5])) && { "aria-label": span0_aria_label_value },
        (!current || dirty & /*$rootCtx*/
        8 && span0_aria_valuemin_value !== (span0_aria_valuemin_value = /*$rootCtx*/
        ctx2[3].min)) && {
          "aria-valuemin": span0_aria_valuemin_value
        },
        (!current || dirty & /*value*/
        4) && { "aria-valuenow": (
          /*value*/
          ctx2[2]
        ) },
        (!current || dirty & /*$rootCtx*/
        8 && span0_aria_valuemax_value !== (span0_aria_valuemax_value = /*$rootCtx*/
        ctx2[3].max)) && {
          "aria-valuemax": span0_aria_valuemax_value
        },
        (!current || dirty & /*$rootCtx*/
        8 && span0_aria_orientation_value !== (span0_aria_orientation_value = /*$rootCtx*/
        ctx2[3].orientation)) && {
          "aria-orientation": span0_aria_orientation_value
        },
        (!current || dirty & /*$rootCtx*/
        8 && span0_data_orientation_value !== (span0_data_orientation_value = /*$rootCtx*/
        ctx2[3].orientation)) && {
          "data-orientation": span0_data_orientation_value
        },
        (!current || dirty & /*$rootCtx*/
        8 && span0_data_disabled_value !== (span0_data_disabled_value = /*$rootCtx*/
        ctx2[3].disabled ? "" : void 0)) && {
          "data-disabled": span0_data_disabled_value
        },
        (!current || dirty & /*$rootCtx*/
        8 && span0_tabindex_value !== (span0_tabindex_value = /*$rootCtx*/
        ctx2[3].disabled ? void 0 : 0)) && { tabindex: span0_tabindex_value }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      1024)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[10].use
        );
      set_style(
        span0,
        "display",
        /*value*/
        ctx2[2] === void 0 ? "none" : "inherit"
      );
      if (!current || dirty & /*style*/
      16) {
        attr_dev(
          span1,
          "style",
          /*style*/
          ctx2[4]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span1);
      }
      if (default_slot)
        default_slot.d(detaching);
      span0_resize_listener();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getLabel(index2, totalValues) {
  if (totalValues > 2) {
    return `Value ${index2 + 1} of ${totalValues}`;
  } else if (totalValues === 2) {
    return ["Minimum", "Maximum"][index2];
  } else {
    return void 0;
  }
}
function getThumbInBoundsOffset(width, left, direction) {
  const halfWidth = width / 2;
  const halfPercent = 50;
  const offset2 = linearScale([0, halfPercent], [0, halfWidth]);
  return (halfWidth - offset2(left) * direction) * direction;
}
function instance18($$self, $$props, $$invalidate) {
  let value;
  let percentage;
  let label;
  let orientationSize;
  let thumbInBoundsOffset;
  let style;
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $orientation;
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Thumb", slots, ["default"]);
  "use strict";
  const rootCtx = getRootContext2();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value2) => $$invalidate(3, $rootCtx = value2));
  const orientation = getOrientationContext();
  validate_store(orientation, "orientation");
  component_subscribe($$self, orientation, (value2) => $$invalidate(15, $orientation = value2));
  let size2 = { width: 0, height: 0 };
  let index = 0;
  const thumbComponentsContext = getThumbCollectionContext();
  function onIndexChange(newIndex) {
    $$invalidate(1, index = newIndex);
  }
  function span0_elementresize_handler() {
    size2.height = this.clientHeight;
    size2.width = this.clientWidth;
    $$invalidate(0, size2);
  }
  const focus_handler = () => {
    set_store_value(rootCtx, $rootCtx.valueIndexToChange = index, $rootCtx);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useCollection,
    styleToString,
    useActions,
    convertValueToPercentage,
    linearScale,
    getOrientationContext,
    getRootContext: getRootContext2,
    getThumbCollectionContext,
    rootCtx,
    orientation,
    size: size2,
    index,
    thumbComponentsContext,
    getLabel,
    getThumbInBoundsOffset,
    onIndexChange,
    thumbInBoundsOffset,
    percentage,
    style,
    orientationSize,
    label,
    value,
    $orientation,
    $rootCtx
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size2 = $$new_props.size);
    if ("index" in $$props)
      $$invalidate(1, index = $$new_props.index);
    if ("thumbInBoundsOffset" in $$props)
      $$invalidate(12, thumbInBoundsOffset = $$new_props.thumbInBoundsOffset);
    if ("percentage" in $$props)
      $$invalidate(13, percentage = $$new_props.percentage);
    if ("style" in $$props)
      $$invalidate(4, style = $$new_props.style);
    if ("orientationSize" in $$props)
      $$invalidate(14, orientationSize = $$new_props.orientationSize);
    if ("label" in $$props)
      $$invalidate(5, label = $$new_props.label);
    if ("value" in $$props)
      $$invalidate(2, value = $$new_props.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$rootCtx, index*/
    10) {
      $:
        $$invalidate(2, value = $rootCtx.values[index]);
    }
    if ($$self.$$.dirty & /*value, $rootCtx*/
    12) {
      $:
        $$invalidate(13, percentage = convertValueToPercentage(value, $rootCtx.min, $rootCtx.max));
    }
    if ($$self.$$.dirty & /*index, $rootCtx*/
    10) {
      $:
        $$invalidate(5, label = getLabel(index, $rootCtx.values.length));
    }
    if ($$self.$$.dirty & /*size, $orientation*/
    32769) {
      $:
        $$invalidate(14, orientationSize = size2[$orientation.size]);
    }
    if ($$self.$$.dirty & /*orientationSize, percentage, $orientation*/
    57344) {
      $:
        $$invalidate(12, thumbInBoundsOffset = orientationSize ? getThumbInBoundsOffset(orientationSize, percentage, $orientation.direction) : 0);
    }
    if ($$self.$$.dirty & /*$orientation, percentage, thumbInBoundsOffset*/
    45056) {
      $:
        $$invalidate(4, style = styleToString({
          transform: `var(--radix-slider-thumb-transform)`,
          position: "absolute",
          [$orientation.startEdge]: `calc(${percentage}% + ${thumbInBoundsOffset}px)`
        }));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    size2,
    index,
    value,
    $rootCtx,
    style,
    label,
    rootCtx,
    orientation,
    thumbComponentsContext,
    onIndexChange,
    $$restProps,
    $$props,
    thumbInBoundsOffset,
    percentage,
    orientationSize,
    $orientation,
    $$scope,
    slots,
    span0_elementresize_handler,
    focus_handler
  ];
}
var Thumb = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Thumb",
      options,
      id: create_fragment18.name
    });
  }
};
var thumb_default = Thumb;

// node_modules/radix-svelte/dist/components/Slider/track.svelte
var file14 = "node_modules/radix-svelte/dist/components/Slider/track.svelte";
function create_fragment19(ctx) {
  let span;
  let span_data_disabled_value;
  let span_data_orientation_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let span_levels = [
    /*$$restProps*/
    ctx[2],
    {
      "data-disabled": span_data_disabled_value = /*$rootCtx*/
      ctx[0].disabled ? "" : void 0
    },
    {
      "data-orientation": span_data_orientation_value = /*$rootCtx*/
      ctx[0].orientation
    }
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        "data-disabled": true,
        "data-orientation": true
      });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file14, 7, 0, 201);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          span,
          /*$$restProps*/
          ctx[2].use
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*$rootCtx*/
        1 && span_data_disabled_value !== (span_data_disabled_value = /*$rootCtx*/
        ctx2[0].disabled ? "" : void 0)) && {
          "data-disabled": span_data_disabled_value
        },
        (!current || dirty & /*$rootCtx*/
        1 && span_data_orientation_value !== (span_data_orientation_value = /*$rootCtx*/
        ctx2[0].orientation)) && {
          "data-orientation": span_data_orientation_value
        }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      4)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[2].use
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Track", slots, ["default"]);
  const rootCtx = getRootContext2();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value) => $$invalidate(0, $rootCtx = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useActions,
    getRootContext: getRootContext2,
    rootCtx,
    $rootCtx
  });
  return [$rootCtx, rootCtx, $$restProps, $$scope, slots];
}
var Track = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Track",
      options,
      id: create_fragment19.name
    });
  }
};
var track_default = Track;

// node_modules/radix-svelte/dist/components/Slider/index.js
var Slider = {
  Root: root_default6,
  Track: track_default,
  Range: range_default,
  Thumb: thumb_default
};

// node_modules/radix-svelte/dist/components/Switch/root.svelte
var file15 = "node_modules/radix-svelte/dist/components/Switch/root.svelte";
function create_if_block3(ctx) {
  let input;
  let input_tabindex_value;
  let input_name_value;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        type: true,
        "aria-hidden": true,
        tabindex: true,
        name: true,
        style: true
      });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "checkbox");
      attr_dev(input, "aria-hidden", "true");
      input.hidden = true;
      attr_dev(input, "tabindex", input_tabindex_value = -1);
      attr_dev(input, "name", input_name_value = /*$$props*/
      ctx[7].name);
      input.value = /*value*/
      ctx[2];
      input.checked = /*checked*/
      ctx[0];
      input.required = /*required*/
      ctx[1];
      input.disabled = /*disabled*/
      ctx[3];
      set_style(input, "position", "absolute");
      set_style(input, "pointer-events", "none");
      set_style(input, "opacity", "0");
      set_style(input, "margin", "0");
      set_style(input, "transform", "translateX(-100%)");
      add_location(input, file15, 42, 1, 1053);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$$props*/
      128 && input_name_value !== (input_name_value = /*$$props*/
      ctx2[7].name)) {
        attr_dev(input, "name", input_name_value);
      }
      if (dirty & /*value*/
      4) {
        prop_dev(
          input,
          "value",
          /*value*/
          ctx2[2]
        );
      }
      if (dirty & /*checked*/
      1) {
        prop_dev(
          input,
          "checked",
          /*checked*/
          ctx2[0]
        );
      }
      if (dirty & /*required*/
      2) {
        prop_dev(
          input,
          "required",
          /*required*/
          ctx2[1]
        );
      }
      if (dirty & /*disabled*/
      8) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[3]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(42:0) {#if isFormControl}",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let button_1;
  let button_1_data_state_value;
  let button_1_data_disabled_value;
  let useActions_action;
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let button_1_levels = [
    { type: "button" },
    { role: "switch" },
    { "aria-checked": (
      /*checked*/
      ctx[0]
    ) },
    {
      "data-state": button_1_data_state_value = getState2(
        /*checked*/
        ctx[0]
      )
    },
    {
      "data-disabled": button_1_data_disabled_value = /*disabled*/
      ctx[3] ? "" : void 0
    },
    { value: (
      /*value*/
      ctx[2]
    ) },
    { disabled: (
      /*disabled*/
      ctx[3]
    ) },
    /*$$restProps*/
    ctx[6]
  ];
  let button_data = {};
  for (let i = 0; i < button_1_levels.length; i += 1) {
    button_data = assign(button_data, button_1_levels[i]);
  }
  let if_block = (
    /*isFormControl*/
    ctx[5] && create_if_block3(ctx)
  );
  const block = {
    c: function create() {
      button_1 = element("button");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      button_1 = claim_element(nodes, "BUTTON", {
        type: true,
        role: true,
        "aria-checked": true,
        "data-state": true,
        "data-disabled": true
      });
      var button_1_nodes = children(button_1);
      if (default_slot)
        default_slot.l(button_1_nodes);
      button_1_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      set_attributes(button_1, button_data);
      add_location(button_1, file15, 23, 0, 734);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button_1, anchor);
      if (default_slot) {
        default_slot.m(button_1, null);
      }
      if (button_1.autofocus)
        button_1.focus();
      ctx[10](button_1);
      insert_hydration_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            button_1,
            /*$$restProps*/
            ctx[6].use
          )),
          listen_dev(
            button_1,
            "click",
            /*click_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(button_1, button_data = get_spread_update(button_1_levels, [
        { type: "button" },
        { role: "switch" },
        (!current || dirty & /*checked*/
        1) && { "aria-checked": (
          /*checked*/
          ctx2[0]
        ) },
        (!current || dirty & /*checked*/
        1 && button_1_data_state_value !== (button_1_data_state_value = getState2(
          /*checked*/
          ctx2[0]
        ))) && { "data-state": button_1_data_state_value },
        (!current || dirty & /*disabled*/
        8 && button_1_data_disabled_value !== (button_1_data_disabled_value = /*disabled*/
        ctx2[3] ? "" : void 0)) && {
          "data-disabled": button_1_data_disabled_value
        },
        (!current || dirty & /*value*/
        4) && { value: (
          /*value*/
          ctx2[2]
        ) },
        (!current || dirty & /*disabled*/
        8) && { disabled: (
          /*disabled*/
          ctx2[3]
        ) },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      64)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[6].use
        );
      if (
        /*isFormControl*/
        ctx2[5]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button_1);
        detach_dev(t);
        detach_dev(if_block_anchor);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[10](null);
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var defaults5 = { checked: false, disabled: false };
var { getContext: getContext7, setContext: setContext7 } = reactiveContext(defaults5);
var getRootContext3 = getContext7;
function getState2(checked) {
  return checked ? "checked" : "unchecked";
}
function instance20($$self, $$props, $$invalidate) {
  let isFormControl;
  const omit_props_names = ["required", "value", "checked", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, ["default"]);
  let { required = false } = $$props;
  let { value = "on" } = $$props;
  let { checked = defaults5.checked } = $$props;
  let { disabled = defaults5.disabled } = $$props;
  let button;
  const ctxStore = setContext7({
    checked: (v) => $$invalidate(0, checked = v)
  });
  function button_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      button = $$value;
      $$invalidate(4, button);
    });
  }
  const click_handler = () => {
    $$invalidate(0, checked = !checked);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("required" in $$new_props)
      $$invalidate(1, required = $$new_props.required);
    if ("value" in $$new_props)
      $$invalidate(2, value = $$new_props.value);
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    defaults: defaults5,
    getContext: getContext7,
    setContext: setContext7,
    getRootContext: getRootContext3,
    getState: getState2,
    useActions,
    reactiveContext,
    required,
    value,
    checked,
    disabled,
    button,
    ctxStore,
    isFormControl
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    if ("required" in $$props)
      $$invalidate(1, required = $$new_props.required);
    if ("value" in $$props)
      $$invalidate(2, value = $$new_props.value);
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("button" in $$props)
      $$invalidate(4, button = $$new_props.button);
    if ("isFormControl" in $$props)
      $$invalidate(5, isFormControl = $$new_props.isFormControl);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*button*/
    16) {
      $:
        $$invalidate(5, isFormControl = button ? button.closest("form") : true);
    }
    if ($$self.$$.dirty & /*checked, disabled*/
    9) {
      $:
        ctxStore.set({ checked, disabled });
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    checked,
    required,
    value,
    disabled,
    button,
    isFormControl,
    $$restProps,
    $$props,
    $$scope,
    slots,
    button_1_binding,
    click_handler
  ];
}
var Root7 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, {
      required: 1,
      value: 2,
      checked: 0,
      disabled: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment20.name
    });
  }
  get required() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var root_default7 = Root7;

// node_modules/radix-svelte/dist/components/Switch/thumb.svelte
var file16 = "node_modules/radix-svelte/dist/components/Switch/thumb.svelte";
function create_fragment21(ctx) {
  let span;
  let span_data_state_value;
  let span_data_disabled_value;
  let useActions_action;
  let mounted;
  let dispose;
  let span_levels = [
    /*$$restProps*/
    ctx[2],
    {
      "data-state": span_data_state_value = getState2(
        /*$rootCtx*/
        ctx[0].checked
      )
    },
    {
      "data-disabled": span_data_disabled_value = /*$rootCtx*/
      ctx[0].disabled ? "" : void 0
    }
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        "data-state": true,
        "data-disabled": true
      });
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file16, 8, 0, 225);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          span,
          /*$$restProps*/
          ctx[2].use
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        dirty & /*$rootCtx*/
        1 && span_data_state_value !== (span_data_state_value = getState2(
          /*$rootCtx*/
          ctx2[0].checked
        )) && { "data-state": span_data_state_value },
        dirty & /*$rootCtx*/
        1 && span_data_disabled_value !== (span_data_disabled_value = /*$rootCtx*/
        ctx2[0].disabled ? "" : void 0) && {
          "data-disabled": span_data_disabled_value
        }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      4)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[2].use
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Thumb", slots, []);
  "use strict";
  const rootCtx = getRootContext3();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value) => $$invalidate(0, $rootCtx = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  $$self.$capture_state = () => ({
    useActions,
    getRootContext: getRootContext3,
    getState: getState2,
    rootCtx,
    $rootCtx
  });
  return [$rootCtx, rootCtx, $$restProps];
}
var Thumb2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Thumb",
      options,
      id: create_fragment21.name
    });
  }
};
var thumb_default2 = Thumb2;

// node_modules/radix-svelte/dist/components/Switch/index.js
var Switch = {
  Root: root_default7,
  Thumb: thumb_default2
};

// node_modules/radix-svelte/dist/components/Toggle/root.svelte
var file17 = "node_modules/radix-svelte/dist/components/Toggle/root.svelte";
function create_fragment22(ctx) {
  let button;
  let button_data_state_value;
  let button_data_disabled_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let button_levels = [
    { type: "button" },
    { disabled: (
      /*disabled*/
      ctx[1]
    ) },
    { "aria-pressed": (
      /*pressed*/
      ctx[0]
    ) },
    {
      "data-state": button_data_state_value = /*pressed*/
      ctx[0] ? "on" : "off"
    },
    {
      "data-disabled": button_data_disabled_value = /*disabled*/
      ctx[1] ? "" : void 0
    },
    /*$$restProps*/
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        "aria-pressed": true,
        "data-state": true,
        "data-disabled": true
      });
      var button_nodes = children(button);
      if (default_slot)
        default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file17, 10, 0, 287);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useActions_action = useActions.call(
            null,
            button,
            /*use*/
            ctx[2] ?? []
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        (!current || dirty & /*disabled*/
        2) && { disabled: (
          /*disabled*/
          ctx2[1]
        ) },
        (!current || dirty & /*pressed*/
        1) && { "aria-pressed": (
          /*pressed*/
          ctx2[0]
        ) },
        (!current || dirty & /*pressed*/
        1 && button_data_state_value !== (button_data_state_value = /*pressed*/
        ctx2[0] ? "on" : "off")) && { "data-state": button_data_state_value },
        (!current || dirty & /*disabled*/
        2 && button_data_disabled_value !== (button_data_disabled_value = /*disabled*/
        ctx2[1] ? "" : void 0)) && {
          "data-disabled": button_data_disabled_value
        },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      4)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[2] ?? []
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  const omit_props_names = ["pressed", "disabled", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, ["default"]);
  let { pressed = false } = $$props;
  let { disabled = false } = $$props;
  const dispatch = createEventDispatcher();
  let { use = [] } = $$props;
  const click_handler = () => {
    $$invalidate(0, pressed = !pressed);
    dispatch("change", pressed);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("pressed" in $$new_props)
      $$invalidate(0, pressed = $$new_props.pressed);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useActions,
    createEventDispatcher,
    pressed,
    disabled,
    dispatch,
    use
  });
  $$self.$inject_state = ($$new_props) => {
    if ("pressed" in $$props)
      $$invalidate(0, pressed = $$new_props.pressed);
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [pressed, disabled, use, dispatch, $$restProps, $$scope, slots, click_handler];
}
var Root8 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, { pressed: 0, disabled: 1, use: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment22.name
    });
  }
  get pressed() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pressed(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var root_default8 = Root8;

// node_modules/radix-svelte/dist/components/Toggle/index.js
var Toggle = {
  Root: root_default8
};

// node_modules/radix-svelte/dist/components/Progress/root.svelte
var file18 = "node_modules/radix-svelte/dist/components/Progress/root.svelte";
function create_fragment23(ctx) {
  let div;
  let div_data_state_value;
  let div_aria_valuemin_value;
  let div_aria_valuetext_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    { role: "progressbar" },
    { "data-value": (
      /*value*/
      ctx[1]
    ) },
    { "data-max": (
      /*max*/
      ctx[0]
    ) },
    {
      "data-state": div_data_state_value = getState3(
        /*value*/
        ctx[1],
        /*max*/
        ctx[0]
      )
    },
    {
      "aria-valuemin": div_aria_valuemin_value = 0
    },
    { "aria-valuemax": (
      /*max*/
      ctx[0]
    ) },
    { "aria-valuenow": (
      /*value*/
      ctx[1]
    ) },
    {
      "aria-valuetext": div_aria_valuetext_value = `${100 * /*value*/
      (ctx[1] ?? 0) / /*max*/
      (ctx[0] ?? 1)}%`
    },
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        role: true,
        "data-value": true,
        "data-max": true,
        "data-state": true,
        "aria-valuemin": true,
        "aria-valuemax": true,
        "aria-valuenow": true,
        "aria-valuetext": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file18, 19, 0, 641);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          div,
          /*$$restProps*/
          ctx[2].use
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { role: "progressbar" },
        (!current || dirty & /*value*/
        2) && { "data-value": (
          /*value*/
          ctx2[1]
        ) },
        (!current || dirty & /*max*/
        1) && { "data-max": (
          /*max*/
          ctx2[0]
        ) },
        (!current || dirty & /*value, max*/
        3 && div_data_state_value !== (div_data_state_value = getState3(
          /*value*/
          ctx2[1],
          /*max*/
          ctx2[0]
        ))) && { "data-state": div_data_state_value },
        { "aria-valuemin": div_aria_valuemin_value },
        (!current || dirty & /*max*/
        1) && { "aria-valuemax": (
          /*max*/
          ctx2[0]
        ) },
        (!current || dirty & /*value*/
        2) && { "aria-valuenow": (
          /*value*/
          ctx2[1]
        ) },
        (!current || dirty & /*value, max*/
        3 && div_aria_valuetext_value !== (div_aria_valuetext_value = `${100 * /*value*/
        (ctx2[1] ?? 0) / /*max*/
        (ctx2[0] ?? 1)}%`)) && {
          "aria-valuetext": div_aria_valuetext_value
        },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      4)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[2].use
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var defaults6 = { max: 1, value: null };
var { getContext: getContext8, setContext: setContext8 } = reactiveContext(defaults6);
var getRootContext4 = getContext8;
function getState3(value, max) {
  return value == null ? "indeterminate" : value >= (max ?? 1) ? "complete" : "loading";
}
function instance23($$self, $$props, $$invalidate) {
  const omit_props_names = ["max", "value"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, ["default"]);
  let { max = defaults6.max } = $$props;
  let { value = defaults6.value } = $$props;
  const ctxStore = setContext8({
    value: (v) => $$invalidate(1, value = v),
    max: (m) => $$invalidate(0, max = m)
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("max" in $$new_props)
      $$invalidate(0, max = $$new_props.max);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    reactiveContext,
    useActions,
    defaults: defaults6,
    getContext: getContext8,
    setContext: setContext8,
    getRootContext: getRootContext4,
    getState: getState3,
    max,
    value,
    ctxStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("max" in $$props)
      $$invalidate(0, max = $$new_props.max);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value, max*/
    3) {
      $:
        ctxStore.set({ value, max });
    }
  };
  return [max, value, $$restProps, $$scope, slots];
}
var Root9 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, { max: 0, value: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment23.name
    });
  }
  get max() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var root_default9 = Root9;

// node_modules/radix-svelte/dist/components/Progress/indicator.svelte
var file19 = "node_modules/radix-svelte/dist/components/Progress/indicator.svelte";
function create_fragment24(ctx) {
  let div;
  let div_data_value_value;
  let div_data_max_value;
  let div_data_state_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[2],
    {
      "data-value": div_data_value_value = /*$ctx*/
      ctx[0].value
    },
    {
      "data-max": div_data_max_value = /*$ctx*/
      ctx[0].max
    },
    {
      "data-state": div_data_state_value = getState3(
        /*$ctx*/
        ctx[0].value,
        /*$ctx*/
        ctx[0].max
      )
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        "data-value": true,
        "data-max": true,
        "data-state": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file19, 8, 0, 221);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          div,
          /*$$restProps*/
          ctx[2].use
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*$ctx*/
        1 && div_data_value_value !== (div_data_value_value = /*$ctx*/
        ctx2[0].value)) && { "data-value": div_data_value_value },
        (!current || dirty & /*$ctx*/
        1 && div_data_max_value !== (div_data_max_value = /*$ctx*/
        ctx2[0].max)) && { "data-max": div_data_max_value },
        (!current || dirty & /*$ctx*/
        1 && div_data_state_value !== (div_data_state_value = getState3(
          /*$ctx*/
          ctx2[0].value,
          /*$ctx*/
          ctx2[0].max
        ))) && { "data-state": div_data_state_value }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      4)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[2].use
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $ctx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Indicator", slots, ["default"]);
  "use strict";
  const ctx = getRootContext4();
  validate_store(ctx, "ctx");
  component_subscribe($$self, ctx, (value) => $$invalidate(0, $ctx = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useActions,
    getRootContext: getRootContext4,
    getState: getState3,
    ctx,
    $ctx
  });
  return [$ctx, ctx, $$restProps, $$scope, slots];
}
var Indicator2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Indicator",
      options,
      id: create_fragment24.name
    });
  }
};
var indicator_default2 = Indicator2;

// node_modules/radix-svelte/dist/components/Progress/index.js
var Progress = {
  Root: root_default9,
  Indicator: indicator_default2
};

// node_modules/radix-svelte/dist/components/Dialog/root.svelte
function create_fragment25(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var { getContext: getContext9, setContext: setContext9, defaults: defaults7 } = reactiveContext({
  open: false,
  modal: true,
  titleId: generateId(),
  descriptionId: generateId(),
  contentId: generateId(),
  triggeredId: null
});
var getDialogRootContext = getContext9;
function instance25($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, ["default"]);
  let { open = defaults7 == null ? void 0 : defaults7.open } = $$props;
  let { modal = defaults7 == null ? void 0 : defaults7.modal } = $$props;
  const rootCtx = setContext9({
    open: (v) => $$invalidate(0, open = v),
    modal: (v) => $$invalidate(1, modal = v)
  });
  const writable_props = ["open", "modal"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Root> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("modal" in $$props2)
      $$invalidate(1, modal = $$props2.modal);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    generateId,
    reactiveContext,
    getContext: getContext9,
    setContext: setContext9,
    defaults: defaults7,
    getDialogRootContext,
    open,
    modal,
    rootCtx
  });
  $$self.$inject_state = ($$props2) => {
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("modal" in $$props2)
      $$invalidate(1, modal = $$props2.modal);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open, modal*/
    3) {
      $:
        rootCtx.update((v) => ({ ...v, open, modal }));
    }
  };
  return [open, modal, $$scope, slots];
}
var Root10 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, { open: 0, modal: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment25.name
    });
  }
  get open() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get modal() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set modal(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var root_default10 = Root10;

// node_modules/radix-svelte/dist/internal/components/Portal/Portal.svelte
var { Error: Error_1 } = globals;
var file20 = "node_modules/radix-svelte/dist/internal/components/Portal/Portal.svelte";
function create_fragment26(ctx) {
  let div;
  let portal_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      div.hidden = true;
      add_location(div, file20, 40, 0, 1163);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(portal_action = portal.call(
          null,
          div,
          /*target*/
          ctx[0]
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (portal_action && is_function(portal_action.update) && dirty & /*target*/
      1)
        portal_action.update.call(
          null,
          /*target*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function portal(el, target = "body") {
  let targetEl;
  async function update(newTarget) {
    target = newTarget;
    if (typeof target === "string") {
      targetEl = document.querySelector(target);
      if (targetEl === null) {
        await tick();
        targetEl = document.querySelector(target);
      }
      if (targetEl === null) {
        throw new Error(`No element found matching css selector: "${target}"`);
      }
    } else if (target instanceof HTMLElement) {
      targetEl = target;
    } else {
      throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
    }
    targetEl.appendChild(el);
    el.hidden = false;
  }
  function destroy() {
    if (el.parentNode) {
      el.parentNode.removeChild(el);
    }
  }
  update(target);
  return { update, destroy };
}
function instance26($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Portal", slots, ["default"]);
  let { target = "body" } = $$props;
  const writable_props = ["target"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Portal> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("target" in $$props2)
      $$invalidate(0, target = $$props2.target);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ tick, portal, target });
  $$self.$inject_state = ($$props2) => {
    if ("target" in $$props2)
      $$invalidate(0, target = $$props2.target);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [target, $$scope, slots];
}
var Portal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, { target: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Portal",
      options,
      id: create_fragment26.name
    });
  }
  get target() {
    throw new Error_1("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error_1("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Portal_default = Portal;

// node_modules/radix-svelte/dist/internal/components/Popper/root.svelte
function create_fragment27(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var { getContext: getContext10, setContext: setContext10 } = reactiveContext({ anchor: null, arrow: null });
var getRootContext5 = getContext10;
function instance27($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, ["default"]);
  "use strict";
  setContext10();
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Root> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    reactiveContext,
    getContext: getContext10,
    setContext: setContext10,
    getRootContext: getRootContext5
  });
  return [$$scope, slots];
}
var Root11 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment27.name
    });
  }
};
var root_default11 = Root11;

// node_modules/radix-svelte/dist/internal/components/Popper/anchor.svelte
var file21 = "node_modules/radix-svelte/dist/internal/components/Popper/anchor.svelte";
function create_dynamic_element(ctx) {
  let svelte_element;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let svelte_element_levels = [
    /*$$restProps*/
    ctx[4]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*as*/
        ctx[1]
      );
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*as*/
        (ctx[1] || "null").toUpperCase(),
        {}
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_dynamic_element_data(
        /*as*/
        ctx[1]
      )(svelte_element, svelte_element_data);
      add_location(svelte_element, file21, 14, 0, 334);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[16](svelte_element);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            svelte_element,
            /*use*/
            ctx[0] ?? []
          )),
          listen_dev(
            svelte_element,
            "click",
            /*click_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "pointerenter",
            /*pointerenter_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "pointermove",
            /*pointermove_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "pointerleave",
            /*pointerleave_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "pointerdown",
            /*pointerdown_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "focus",
            /*focus_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "blur",
            /*blur_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "touchstart",
            /*touchstart_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_dynamic_element_data(
        /*as*/
        ctx2[1]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [dirty & /*$$restProps*/
      16 && /*$$restProps*/
      ctx2[4]]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0] ?? []
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[16](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: "(15:0) <svelte:element  this={as}  {...$$restProps}  use:useActions={use ?? []}  bind:this={element}  on:click  on:pointerenter  on:pointermove  on:pointerleave  on:pointerdown  on:focus  on:blur  on:touchstart >",
    ctx
  });
  return block;
}
function create_fragment28(ctx) {
  let previous_tag = (
    /*as*/
    ctx[1]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*as*/
    ctx[1]
  );
  validate_void_dynamic_element(
    /*as*/
    ctx[1]
  );
  let svelte_element = (
    /*as*/
    ctx[1] && create_dynamic_element(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*as*/
        ctx2[1]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*as*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*as*/
          ctx2[1]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*as*/
            ctx2[1]
          );
          validate_void_dynamic_element(
            /*as*/
            ctx2[1]
          );
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*as*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*as*/
        ctx2[1];
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "as", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootContext;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Anchor", slots, ["default"]);
  let { use = [] } = $$props;
  let { as = "div" } = $$props;
  let { ref = null } = $$props;
  let element2;
  const rootContext = getRootContext5();
  validate_store(rootContext, "rootContext");
  component_subscribe($$self, rootContext, (value) => $$invalidate(17, $rootContext = value));
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchstart_handler2(event) {
    bubble.call(this, $$self, event);
  }
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("as" in $$new_props)
      $$invalidate(1, as = $$new_props.as);
    if ("ref" in $$new_props)
      $$invalidate(5, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useActions,
    getRootContext: getRootContext5,
    use,
    as,
    ref,
    element: element2,
    rootContext,
    $rootContext
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("as" in $$props)
      $$invalidate(1, as = $$new_props.as);
    if ("ref" in $$props)
      $$invalidate(5, ref = $$new_props.ref);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*element*/
    4) {
      $:
        if (element2)
          $$invalidate(5, ref = element2);
    }
    if ($$self.$$.dirty & /*element*/
    4) {
      $:
        set_store_value(rootContext, $rootContext.anchor = element2, $rootContext);
    }
  };
  return [
    use,
    as,
    element2,
    rootContext,
    $$restProps,
    ref,
    $$scope,
    slots,
    click_handler,
    pointerenter_handler,
    pointermove_handler,
    pointerleave_handler,
    pointerdown_handler,
    focus_handler,
    blur_handler,
    touchstart_handler2,
    svelte_element_binding
  ];
}
var Anchor = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, { use: 0, as: 1, ref: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Anchor",
      options,
      id: create_fragment28.name
    });
  }
  get use() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get as() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var anchor_default = Anchor;

// node_modules/radix-svelte/dist/internal/components/Popper/utils.js
function isDefined(value) {
  return value !== void 0;
}
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _a, _b, _c;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_a = middlewareData.arrow) == null ? void 0 : _a.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (((_b = middlewareData.arrow) == null ? void 0 : _b.x) ?? 0) + arrowWidth / 2;
    const arrowYCenter = (((_c = middlewareData.arrow) == null ? void 0 : _c.y) ?? 0) + arrowHeight / 2;
    let x = "";
    let y = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}

// node_modules/radix-svelte/dist/internal/components/Popper/content.svelte
var file22 = "node_modules/radix-svelte/dist/internal/components/Popper/content.svelte";
function create_fragment29(ctx) {
  let div1;
  let div0;
  let style_animation = `${/*isPlaced*/
  ctx[9] ? void 0 : "none"},`;
  let div1_dir_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[33].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[32],
    null
  );
  let div0_levels = [
    /*$$restProps*/
    ctx[12],
    { "data-side": (
      /*placedSide*/
      ctx[5]
    ) },
    { "data-align": (
      /*placedAlign*/
      ctx[8]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div0_levels.length; i += 1) {
    div_data = assign(div_data, div0_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {
        "data-radix-popper-content-wrapper": true,
        dir: true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { "data-side": true, "data-align": true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a, _b, _c, _d, _e, _f;
      set_attributes(div0, div_data);
      set_style(div0, "animation", style_animation);
      set_style(
        div0,
        "opacity",
        /*middlewareData*/
        ((_b = (_a = ctx[2]) == null ? void 0 : _a.hide) == null ? void 0 : _b.referenceHidden) ? 0 : void 0
      );
      add_location(div0, file22, 134, 1, 5094);
      attr_dev(div1, "data-radix-popper-content-wrapper", "");
      attr_dev(div1, "dir", div1_dir_value = /*$$restProps*/
      ctx[12].dir);
      set_style(
        div1,
        "position",
        /*strategy*/
        ctx[6]
      );
      set_style(div1, "left", 0);
      set_style(div1, "top", 0);
      set_style(
        div1,
        "transform",
        /*isPlaced*/
        ctx[9] ? `translate3d(${Math.round(
          /*x*/
          ctx[3] ?? 0
        )}px, ${Math.round(
          /*y*/
          ctx[4] ?? 0
        )}px, 0)` : "translate3d(0, -200%, 0)"
      );
      set_style(div1, "min-width", `max-content`);
      set_style(
        div1,
        "z-index",
        /*contentZIndex*/
        ctx[7]
      );
      set_style(
        div1,
        "--radix-popper-transform-origin",
        /*middlewareData*/
        ((_d = (_c = ctx[2]) == null ? void 0 : _c.transformOrigin) == null ? void 0 : _d.x) + " " + /*middlewareData*/
        ((_f = (_e = ctx[2]) == null ? void 0 : _e.transformOrigin) == null ? void 0 : _f.y)
      );
      add_location(div1, file22, 113, 0, 4550);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[38](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "pointerenter",
            /*pointerenter_handler*/
            ctx[34],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "pointerleave",
            /*pointerleave_handler*/
            ctx[35],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "blur",
            /*blur_handler*/
            ctx[36],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "focus",
            /*focus_handler*/
            ctx[37],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useActions_action = useActions.call(
            null,
            div1,
            /*use*/
            ctx[0] ?? []
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      var _a, _b, _c, _d, _e, _f;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[32],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[32]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[32],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div0, div_data = get_spread_update(div0_levels, [
        dirty[0] & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12],
        (!current || dirty[0] & /*placedSide*/
        32) && { "data-side": (
          /*placedSide*/
          ctx2[5]
        ) },
        (!current || dirty[0] & /*placedAlign*/
        256) && { "data-align": (
          /*placedAlign*/
          ctx2[8]
        ) }
      ]));
      if (dirty[0] & /*isPlaced*/
      512) {
        style_animation = `${/*isPlaced*/
        ctx2[9] ? void 0 : "none"},`;
      }
      set_style(div0, "animation", style_animation);
      set_style(
        div0,
        "opacity",
        /*middlewareData*/
        ((_b = (_a = ctx2[2]) == null ? void 0 : _a.hide) == null ? void 0 : _b.referenceHidden) ? 0 : void 0
      );
      if (!current || dirty[0] & /*$$restProps*/
      4096 && div1_dir_value !== (div1_dir_value = /*$$restProps*/
      ctx2[12].dir)) {
        attr_dev(div1, "dir", div1_dir_value);
      }
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0] ?? []
        );
      if (dirty[0] & /*strategy*/
      64) {
        set_style(
          div1,
          "position",
          /*strategy*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*isPlaced, x, y*/
      536) {
        set_style(
          div1,
          "transform",
          /*isPlaced*/
          ctx2[9] ? `translate3d(${Math.round(
            /*x*/
            ctx2[3] ?? 0
          )}px, ${Math.round(
            /*y*/
            ctx2[4] ?? 0
          )}px, 0)` : "translate3d(0, -200%, 0)"
        );
      }
      if (dirty[0] & /*contentZIndex*/
      128) {
        set_style(
          div1,
          "z-index",
          /*contentZIndex*/
          ctx2[7]
        );
      }
      if (dirty[0] & /*middlewareData*/
      4) {
        set_style(
          div1,
          "--radix-popper-transform-origin",
          /*middlewareData*/
          ((_d = (_c = ctx2[2]) == null ? void 0 : _c.transformOrigin) == null ? void 0 : _d.x) + " " + /*middlewareData*/
          ((_f = (_e = ctx2[2]) == null ? void 0 : _e.transformOrigin) == null ? void 0 : _f.y)
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[38](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var defaults8 = { placedSide: "bottom" };
var { getContext: getContext11, setContext: setContext11 } = reactiveContext(defaults8);
var getPopperContentContext = getContext11;
function instance29($$self, $$props, $$invalidate) {
  let desiredPlacement;
  let boundary;
  let hasExplicitBoundaries;
  let detectOverflowOptions;
  let isPlaced;
  let placedSide;
  let placedAlign;
  let contentZIndex;
  const omit_props_names = [
    "use",
    "ref",
    "side",
    "sideOffset",
    "align",
    "alignOffset",
    "arrowPadding",
    "collisionBoundary",
    "collisionPadding",
    "sticky",
    "hideWhenDetached",
    "avoidCollisions"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let $ctx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Content", slots, ["default"]);
  let { use = [] } = $$props;
  let { ref = null } = $$props;
  let { side = defaults8.placedSide } = $$props;
  let { sideOffset = 0 } = $$props;
  let { align = "center" } = $$props;
  let { alignOffset = 0 } = $$props;
  let { arrowPadding = 0 } = $$props;
  let { collisionBoundary = [] } = $$props;
  let { collisionPadding = 0 } = $$props;
  let { sticky = "partial" } = $$props;
  let { hideWhenDetached = false } = $$props;
  let { avoidCollisions = true } = $$props;
  const rootCtx = getRootContext5();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value) => $$invalidate(30, $rootCtx = value));
  const ctx = setContext11();
  validate_store(ctx, "ctx");
  component_subscribe($$self, ctx, (value) => $$invalidate(31, $ctx = value));
  let content;
  onDestroy(() => {
    $$invalidate(14, ref = null);
  });
  let strategy;
  let placement;
  let middlewareData;
  let x = null;
  let y = null;
  function updatePosition(options) {
    computePosition($rootCtx.anchor, content, options).then(async (position) => {
      $$invalidate(6, { strategy, placement, middlewareData, x, y } = position, strategy, $$invalidate(24, placement), $$invalidate(2, middlewareData), $$invalidate(3, x), $$invalidate(4, y));
    });
  }
  let cleanup = null;
  onDestroy(() => {
    cleanup == null ? void 0 : cleanup();
  });
  function pointerenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      content = $$value;
      $$invalidate(1, content);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("ref" in $$new_props)
      $$invalidate(14, ref = $$new_props.ref);
    if ("side" in $$new_props)
      $$invalidate(15, side = $$new_props.side);
    if ("sideOffset" in $$new_props)
      $$invalidate(16, sideOffset = $$new_props.sideOffset);
    if ("align" in $$new_props)
      $$invalidate(17, align = $$new_props.align);
    if ("alignOffset" in $$new_props)
      $$invalidate(18, alignOffset = $$new_props.alignOffset);
    if ("arrowPadding" in $$new_props)
      $$invalidate(19, arrowPadding = $$new_props.arrowPadding);
    if ("collisionBoundary" in $$new_props)
      $$invalidate(20, collisionBoundary = $$new_props.collisionBoundary);
    if ("collisionPadding" in $$new_props)
      $$invalidate(13, collisionPadding = $$new_props.collisionPadding);
    if ("sticky" in $$new_props)
      $$invalidate(21, sticky = $$new_props.sticky);
    if ("hideWhenDetached" in $$new_props)
      $$invalidate(22, hideWhenDetached = $$new_props.hideWhenDetached);
    if ("avoidCollisions" in $$new_props)
      $$invalidate(23, avoidCollisions = $$new_props.avoidCollisions);
    if ("$$scope" in $$new_props)
      $$invalidate(32, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    defaults: defaults8,
    getContext: getContext11,
    setContext: setContext11,
    getPopperContentContext,
    flip,
    hide,
    limitShift,
    offset,
    shift,
    size,
    autoUpdate,
    floatingUIarrow: arrow,
    platform,
    computePosition,
    reactiveContext,
    useActions,
    onDestroy,
    getRootContext: getRootContext5,
    getSideAndAlignFromPlacement,
    isDefined,
    isNotNull,
    transformOrigin,
    use,
    ref,
    side,
    sideOffset,
    align,
    alignOffset,
    arrowPadding,
    collisionBoundary,
    collisionPadding,
    sticky,
    hideWhenDetached,
    avoidCollisions,
    rootCtx,
    ctx,
    content,
    strategy,
    placement,
    middlewareData,
    x,
    y,
    updatePosition,
    cleanup,
    contentZIndex,
    placedSide,
    placedAlign,
    isPlaced,
    detectOverflowOptions,
    desiredPlacement,
    hasExplicitBoundaries,
    boundary,
    $rootCtx,
    $ctx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("ref" in $$props)
      $$invalidate(14, ref = $$new_props.ref);
    if ("side" in $$props)
      $$invalidate(15, side = $$new_props.side);
    if ("sideOffset" in $$props)
      $$invalidate(16, sideOffset = $$new_props.sideOffset);
    if ("align" in $$props)
      $$invalidate(17, align = $$new_props.align);
    if ("alignOffset" in $$props)
      $$invalidate(18, alignOffset = $$new_props.alignOffset);
    if ("arrowPadding" in $$props)
      $$invalidate(19, arrowPadding = $$new_props.arrowPadding);
    if ("collisionBoundary" in $$props)
      $$invalidate(20, collisionBoundary = $$new_props.collisionBoundary);
    if ("collisionPadding" in $$props)
      $$invalidate(13, collisionPadding = $$new_props.collisionPadding);
    if ("sticky" in $$props)
      $$invalidate(21, sticky = $$new_props.sticky);
    if ("hideWhenDetached" in $$props)
      $$invalidate(22, hideWhenDetached = $$new_props.hideWhenDetached);
    if ("avoidCollisions" in $$props)
      $$invalidate(23, avoidCollisions = $$new_props.avoidCollisions);
    if ("content" in $$props)
      $$invalidate(1, content = $$new_props.content);
    if ("strategy" in $$props)
      $$invalidate(6, strategy = $$new_props.strategy);
    if ("placement" in $$props)
      $$invalidate(24, placement = $$new_props.placement);
    if ("middlewareData" in $$props)
      $$invalidate(2, middlewareData = $$new_props.middlewareData);
    if ("x" in $$props)
      $$invalidate(3, x = $$new_props.x);
    if ("y" in $$props)
      $$invalidate(4, y = $$new_props.y);
    if ("cleanup" in $$props)
      $$invalidate(25, cleanup = $$new_props.cleanup);
    if ("contentZIndex" in $$props)
      $$invalidate(7, contentZIndex = $$new_props.contentZIndex);
    if ("placedSide" in $$props)
      $$invalidate(5, placedSide = $$new_props.placedSide);
    if ("placedAlign" in $$props)
      $$invalidate(8, placedAlign = $$new_props.placedAlign);
    if ("isPlaced" in $$props)
      $$invalidate(9, isPlaced = $$new_props.isPlaced);
    if ("detectOverflowOptions" in $$props)
      $$invalidate(26, detectOverflowOptions = $$new_props.detectOverflowOptions);
    if ("desiredPlacement" in $$props)
      $$invalidate(27, desiredPlacement = $$new_props.desiredPlacement);
    if ("hasExplicitBoundaries" in $$props)
      $$invalidate(28, hasExplicitBoundaries = $$new_props.hasExplicitBoundaries);
    if ("boundary" in $$props)
      $$invalidate(29, boundary = $$new_props.boundary);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a, _b, _c;
    if ($$self.$$.dirty[0] & /*content*/
    2) {
      $:
        if (content) {
          $$invalidate(14, ref = content);
        }
    }
    if ($$self.$$.dirty[0] & /*side, align*/
    163840) {
      $:
        $$invalidate(27, desiredPlacement = side + (align !== "center" ? "-" + align : ""));
    }
    if ($$self.$$.dirty[0] & /*collisionPadding*/
    8192) {
      $:
        $$invalidate(13, collisionPadding = typeof collisionPadding === "number" ? collisionPadding : {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0,
          ...collisionPadding
        });
    }
    if ($$self.$$.dirty[0] & /*collisionBoundary*/
    1048576) {
      $:
        $$invalidate(29, boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary]);
    }
    if ($$self.$$.dirty[0] & /*boundary*/
    536870912) {
      $:
        $$invalidate(28, hasExplicitBoundaries = boundary.length > 0);
    }
    if ($$self.$$.dirty[0] & /*collisionPadding, boundary, hasExplicitBoundaries*/
    805314560) {
      $:
        $$invalidate(26, detectOverflowOptions = {
          padding: collisionPadding,
          boundary: boundary.filter(isNotNull),
          // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
          altBoundary: hasExplicitBoundaries
        });
    }
    if ($$self.$$.dirty[0] & /*content, $rootCtx, cleanup, desiredPlacement, sideOffset, alignOffset, avoidCollisions, sticky, detectOverflowOptions, arrowPadding, hideWhenDetached*/
    1324154882 | $$self.$$.dirty[1] & /*$ctx*/
    1) {
      $:
        if (content && $rootCtx.anchor) {
          if (cleanup)
            cleanup();
          $$invalidate(25, cleanup = autoUpdate($rootCtx.anchor, content, () => {
            const arrowWidth = $ctx.arrowWidth ?? 0;
            const arrowHeight = $ctx.arrowHeight ?? 0;
            updatePosition({
              platform,
              strategy: "fixed",
              placement: desiredPlacement,
              middleware: [
                offset({
                  mainAxis: sideOffset + arrowHeight,
                  alignmentAxis: alignOffset
                }),
                avoidCollisions ? shift({
                  mainAxis: true,
                  crossAxis: false,
                  limiter: sticky === "partial" ? limitShift() : void 0,
                  ...detectOverflowOptions
                }) : void 0,
                avoidCollisions ? flip({ ...detectOverflowOptions }) : void 0,
                size({
                  ...detectOverflowOptions,
                  apply: ({ elements, rects, availableWidth, availableHeight }) => {
                    const { width: anchorWidth, height: anchorHeight } = rects.reference;
                    const contentStyle = elements.floating.style;
                    contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
                    contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
                    contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
                    contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
                  }
                }),
                $rootCtx.arrow ? arrow({
                  element: $rootCtx.arrow,
                  padding: arrowPadding
                }) : void 0,
                transformOrigin({ arrowWidth, arrowHeight }),
                hideWhenDetached ? hide({ strategy: "referenceHidden" }) : void 0
              ].filter(isDefined)
            });
          }));
        }
    }
    if ($$self.$$.dirty[0] & /*x, y*/
    24) {
      $:
        $$invalidate(9, isPlaced = x !== null && y !== null);
    }
    if ($$self.$$.dirty[0] & /*placement, side*/
    16809984) {
      $:
        $$invalidate(
          5,
          [placedSide, placedAlign] = placement ? getSideAndAlignFromPlacement(placement) : [side, void 0],
          placedSide,
          ($$invalidate(8, placedAlign), $$invalidate(24, placement), $$invalidate(15, side))
        );
    }
    if ($$self.$$.dirty[0] & /*middlewareData, placedSide*/
    36) {
      $: {
        const arrowX = ((_a = middlewareData == null ? void 0 : middlewareData.arrow) == null ? void 0 : _a.x) || 0;
        const arrowY = ((_b = middlewareData == null ? void 0 : middlewareData.arrow) == null ? void 0 : _b.y) || 0;
        const cannotCenterArrow = ((_c = middlewareData == null ? void 0 : middlewareData.arrow) == null ? void 0 : _c.centerOffset) !== 0;
        ctx.update((old) => ({
          ...old,
          placedSide,
          arrowX,
          arrowY,
          shouldHideArrow: cannotCenterArrow
        }));
      }
    }
    if ($$self.$$.dirty[0] & /*content*/
    2) {
      $:
        $$invalidate(7, contentZIndex = content && (window == null ? void 0 : window.getComputedStyle(content).zIndex) || 0);
    }
  };
  return [
    use,
    content,
    middlewareData,
    x,
    y,
    placedSide,
    strategy,
    contentZIndex,
    placedAlign,
    isPlaced,
    rootCtx,
    ctx,
    $$restProps,
    collisionPadding,
    ref,
    side,
    sideOffset,
    align,
    alignOffset,
    arrowPadding,
    collisionBoundary,
    sticky,
    hideWhenDetached,
    avoidCollisions,
    placement,
    cleanup,
    detectOverflowOptions,
    desiredPlacement,
    hasExplicitBoundaries,
    boundary,
    $rootCtx,
    $ctx,
    $$scope,
    slots,
    pointerenter_handler,
    pointerleave_handler,
    blur_handler,
    focus_handler,
    div1_binding
  ];
}
var Content3 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance29,
      create_fragment29,
      safe_not_equal,
      {
        use: 0,
        ref: 14,
        side: 15,
        sideOffset: 16,
        align: 17,
        alignOffset: 18,
        arrowPadding: 19,
        collisionBoundary: 20,
        collisionPadding: 13,
        sticky: 21,
        hideWhenDetached: 22,
        avoidCollisions: 23
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Content",
      options,
      id: create_fragment29.name
    });
  }
  get use() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get side() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set side(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sideOffset() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sideOffset(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alignOffset() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alignOffset(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrowPadding() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrowPadding(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get collisionBoundary() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set collisionBoundary(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get collisionPadding() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set collisionPadding(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sticky() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sticky(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideWhenDetached() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideWhenDetached(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get avoidCollisions() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set avoidCollisions(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var content_default3 = Content3;

// node_modules/radix-svelte/dist/components/Arrow/root.svelte
var file23 = "node_modules/radix-svelte/dist/components/Arrow/root.svelte";
function create_else_block(ctx) {
  let polygon;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", { points: true });
      children(polygon).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "0,0 30,0 15,10");
      add_location(polygon, file23, 11, 2, 247);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(polygon);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(11:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(9:1) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_fragment30(ctx) {
  let svg;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block4, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[3].default
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let svg_levels = [
    /*$$restProps*/
    ctx[2],
    { width: (
      /*width*/
      ctx[0]
    ) },
    { height: (
      /*height*/
      ctx[1]
    ) },
    { viewBox: "0 0 30 10" },
    { preserveAspectRatio: "none" }
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if_block.c();
      if_block_anchor = empty();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        preserveAspectRatio: true
      });
      var svg_nodes = children(svg);
      if_block.l(svg_nodes);
      if_block_anchor = empty();
      if (default_slot)
        default_slot.l(svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(svg, svg_data);
      add_location(svg, file23, 7, 0, 115);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if_blocks[current_block_type_index].m(svg, null);
      append_hydration_dev(svg, if_block_anchor);
      if (default_slot) {
        default_slot.m(svg, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(svg, if_block_anchor);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*width*/
        1) && { width: (
          /*width*/
          ctx2[0]
        ) },
        (!current || dirty & /*height*/
        2) && { height: (
          /*height*/
          ctx2[1]
        ) },
        { viewBox: "0 0 30 10" },
        { preserveAspectRatio: "none" }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if_blocks[current_block_type_index].d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  const omit_props_names = ["width", "height"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, ["default"]);
  const $$slots = compute_slots(slots);
  let { width = 10 } = $$props;
  let { height = 5 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("width" in $$new_props)
      $$invalidate(0, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(1, height = $$new_props.height);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ width, height });
  $$self.$inject_state = ($$new_props) => {
    if ("width" in $$props)
      $$invalidate(0, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(1, height = $$new_props.height);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [width, height, $$restProps, $$slots, $$scope, slots];
}
var Root12 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, { width: 0, height: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment30.name
    });
  }
  get width() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var root_default12 = Root12;

// node_modules/radix-svelte/dist/components/Arrow/index.js
var Arrow = {
  Root: root_default12
};

// node_modules/radix-svelte/dist/internal/components/Popper/arrow.svelte
var file24 = "node_modules/radix-svelte/dist/internal/components/Popper/arrow.svelte";
function create_fragment31(ctx) {
  let span;
  let arrow_root;
  let current;
  const arrow_root_spread_levels = [
    /*$$restProps*/
    ctx[6],
    {
      style: (
        /*$$restProps*/
        (ctx[6].style ?? "") + "; display:block"
      )
    },
    { width: (
      /*width*/
      ctx[0]
    ) },
    { height: (
      /*height*/
      ctx[1]
    ) }
  ];
  let arrow_root_props = {};
  for (let i = 0; i < arrow_root_spread_levels.length; i += 1) {
    arrow_root_props = assign(arrow_root_props, arrow_root_spread_levels[i]);
  }
  arrow_root = new Arrow.Root({ props: arrow_root_props, $$inline: true });
  const block = {
    c: function create() {
      span = element("span");
      create_component(arrow_root.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { style: true });
      var span_nodes = children(span);
      claim_component(arrow_root.$$.fragment, span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        span,
        "style",
        /*style*/
        ctx[2]
      );
      add_location(span, file24, 39, 0, 1346);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      mount_component(arrow_root, span, null);
      ctx[9](span);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const arrow_root_changes = dirty & /*$$restProps, width, height*/
      67 ? get_spread_update(arrow_root_spread_levels, [
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx2[6]
        ),
        dirty & /*$$restProps*/
        64 && {
          style: (
            /*$$restProps*/
            (ctx2[6].style ?? "") + "; display:block"
          )
        },
        dirty & /*width*/
        1 && { width: (
          /*width*/
          ctx2[0]
        ) },
        dirty & /*height*/
        2 && { height: (
          /*height*/
          ctx2[1]
        ) }
      ]) : {};
      arrow_root.$set(arrow_root_changes);
      if (!current || dirty & /*style*/
      4) {
        attr_dev(
          span,
          "style",
          /*style*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(arrow_root.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(arrow_root.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      destroy_component(arrow_root);
      ctx[9](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self, $$props, $$invalidate) {
  let baseSide;
  let style;
  const omit_props_names = ["width", "height"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $contentContext;
  let $rootContext;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Arrow", slots, []);
  const OPPOSITE_SIDE = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
  };
  let { width = void 0 } = $$props;
  let { height = void 0 } = $$props;
  const rootContext = getRootContext5();
  validate_store(rootContext, "rootContext");
  component_subscribe($$self, rootContext, (value) => $$invalidate(3, $rootContext = value));
  const contentContext = getPopperContentContext();
  validate_store(contentContext, "contentContext");
  component_subscribe($$self, contentContext, (value) => $$invalidate(8, $contentContext = value));
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $rootContext.arrow = $$value;
      rootContext.set($rootContext);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("width" in $$new_props)
      $$invalidate(0, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(1, height = $$new_props.height);
  };
  $$self.$capture_state = () => ({
    Arrow,
    styleToString,
    getPopperContentContext,
    getRootContext: getRootContext5,
    OPPOSITE_SIDE,
    width,
    height,
    rootContext,
    contentContext,
    baseSide,
    style,
    $contentContext,
    $rootContext
  });
  $$self.$inject_state = ($$new_props) => {
    if ("width" in $$props)
      $$invalidate(0, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(1, height = $$new_props.height);
    if ("baseSide" in $$props)
      $$invalidate(7, baseSide = $$new_props.baseSide);
    if ("style" in $$props)
      $$invalidate(2, style = $$new_props.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*width, height*/
    3) {
      $:
        contentContext.update((old) => ({
          ...old,
          arrowWidth: width,
          arrowHeight: height
        }));
    }
    if ($$self.$$.dirty & /*$contentContext*/
    256) {
      $:
        $$invalidate(7, baseSide = OPPOSITE_SIDE[$contentContext.placedSide]);
    }
    if ($$self.$$.dirty & /*$contentContext, baseSide*/
    384) {
      $:
        $$invalidate(2, style = styleToString({
          position: "absolute",
          left: $contentContext.arrowX ? $contentContext.arrowX + "px" : void 0,
          top: $contentContext.arrowY ? $contentContext.arrowY + "px" : void 0,
          [baseSide]: 0,
          "transform-origin": {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[$contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[$contentContext.placedSide],
          visibility: $contentContext.shouldHideArrow ? "hidden" : "initial"
        }));
    }
  };
  return [
    width,
    height,
    style,
    $rootContext,
    rootContext,
    contentContext,
    $$restProps,
    baseSide,
    $contentContext,
    span_binding
  ];
}
var Arrow_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, { width: 0, height: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Arrow_1",
      options,
      id: create_fragment31.name
    });
  }
  get width() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var arrow_default = Arrow_1;

// node_modules/radix-svelte/dist/internal/components/Popper/index.js
var Popper = {
  Root: root_default11,
  Anchor: anchor_default,
  Arrow: arrow_default,
  Content: content_default3
};

// node_modules/radix-svelte/dist/components/Dialog/portal.svelte
function create_if_block5(ctx) {
  let portal2;
  let current;
  const portal_spread_levels = [
    { target: (
      /*container*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let portal_props = {
    $$slots: { default: [create_default_slot7] },
    $$scope: { ctx }
  };
  for (let i = 0; i < portal_spread_levels.length; i += 1) {
    portal_props = assign(portal_props, portal_spread_levels[i]);
  }
  portal2 = new Portal_default({ props: portal_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(portal2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(portal2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(portal2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const portal_changes = dirty & /*container, $$restProps*/
      9 ? get_spread_update(portal_spread_levels, [
        dirty & /*container*/
        1 && { target: (
          /*container*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      32) {
        portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portal2.$set(portal_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(portal2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(portal2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(portal2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(9:0) {#if $rootCtx.open}",
    ctx
  });
  return block;
}
function create_default_slot7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: "(10:1) <Portal target={container} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment32(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$rootCtx*/
    ctx[1].open && create_if_block5(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$rootCtx*/
        ctx2[1].open
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$rootCtx*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  const omit_props_names = ["container"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Portal", slots, ["default"]);
  let { container = "body" } = $$props;
  const rootCtx = getDialogRootContext();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value) => $$invalidate(1, $rootCtx = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("container" in $$new_props)
      $$invalidate(0, container = $$new_props.container);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Portal: Portal_default,
    getDialogRootContext,
    container,
    rootCtx,
    $rootCtx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("container" in $$props)
      $$invalidate(0, container = $$new_props.container);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [container, $rootCtx, rootCtx, $$restProps, slots, $$scope];
}
var Portal_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, { container: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Portal_1",
      options,
      id: create_fragment32.name
    });
  }
  get container() {
    throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var portal_default = Portal_1;

// node_modules/radix-svelte/dist/components/Dialog/internal/helpers.js
function getDataState(open) {
  return open ? "open" : "closed";
}

// node_modules/radix-svelte/dist/components/Dialog/trigger.svelte
var file25 = "node_modules/radix-svelte/dist/components/Dialog/trigger.svelte";
function create_fragment33(ctx) {
  let button;
  let button_aria_expanded_value;
  let button_data_state_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let button_levels = [
    { "aria-haspopup": "dialog" },
    {
      "aria-expanded": button_aria_expanded_value = /*$rootCtx*/
      ctx[0].open
    },
    {
      "data-state": button_data_state_value = getDataState(
        /*$rootCtx*/
        ctx[0].open
      )
    },
    { id: (
      /*id*/
      ctx[2]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        "aria-haspopup": true,
        "aria-expanded": true,
        "data-state": true,
        id: true
      });
      var button_nodes = children(button);
      if (default_slot)
        default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file25, 11, 0, 329);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[6],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { "aria-haspopup": "dialog" },
        (!current || dirty & /*$rootCtx*/
        1 && button_aria_expanded_value !== (button_aria_expanded_value = /*$rootCtx*/
        ctx2[0].open)) && {
          "aria-expanded": button_aria_expanded_value
        },
        (!current || dirty & /*$rootCtx*/
        1 && button_data_state_value !== (button_data_state_value = getDataState(
          /*$rootCtx*/
          ctx2[0].open
        ))) && { "data-state": button_data_state_value },
        { id: (
          /*id*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Trigger", slots, ["default"]);
  "use strict";
  const rootCtx = getDialogRootContext();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value) => $$invalidate(0, $rootCtx = value));
  const id = generateId();
  const click_handler = () => {
    set_store_value(rootCtx, $rootCtx.open = true, $rootCtx);
    set_store_value(rootCtx, $rootCtx.triggeredId = $rootCtx.open ? id : null, $rootCtx);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    generateId,
    getDataState,
    getDialogRootContext,
    rootCtx,
    id,
    $rootCtx
  });
  return [$rootCtx, rootCtx, id, $$restProps, $$scope, slots, click_handler];
}
var Trigger3 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Trigger",
      options,
      id: create_fragment33.name
    });
  }
};
var trigger_default3 = Trigger3;

// node_modules/radix-svelte/dist/internal/actions/removeScroll.js
function noop2() {
}
var LOCK_CLASSNAME = "data-radix-scroll-lock";
function assignStyle(el, style) {
  if (!el)
    return;
  const previousStyle = el.style.cssText;
  Object.assign(el.style, style);
  return () => {
    el.style.cssText = previousStyle;
  };
}
function setCSSProperty(el, property, value) {
  if (!el)
    return;
  const previousValue = el.style.getPropertyValue(property);
  el.style.setProperty(property, value);
  return () => {
    if (previousValue) {
      el.style.setProperty(property, previousValue);
    } else {
      el.style.removeProperty(property);
    }
  };
}
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function removeScroll(_node, { disable } = {}) {
  const win = document.defaultView ?? window;
  const { documentElement, body } = document;
  let cleanups = [];
  const init2 = () => {
    const locked = body.hasAttribute(LOCK_CLASSNAME);
    if (locked)
      return noop2;
    body.setAttribute(LOCK_CLASSNAME, "");
    const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
    const setScrollbarWidthProperty = () => setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
    const paddingProperty = getPaddingProperty(documentElement);
    const setStyle = () => assignStyle(body, {
      overflow: "hidden",
      [paddingProperty]: `${scrollbarWidth}px`
    });
    const setIOSStyle = () => {
      const { scrollX, scrollY, visualViewport } = win;
      const offsetLeft = (visualViewport == null ? void 0 : visualViewport.offsetLeft) ?? 0;
      const offsetTop = (visualViewport == null ? void 0 : visualViewport.offsetTop) ?? 0;
      const restoreStyle = assignStyle(body, {
        position: "fixed",
        overflow: "hidden",
        top: `${-(scrollY - Math.floor(offsetTop))}px`,
        left: `${-(scrollX - Math.floor(offsetLeft))}px`,
        right: "0",
        [paddingProperty]: `${scrollbarWidth}px`
      });
      return () => {
        restoreStyle == null ? void 0 : restoreStyle();
        win.scrollTo(scrollX, scrollY);
      };
    };
    cleanups = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle()];
  };
  const unsub = () => {
    cleanups.forEach((fn) => fn == null ? void 0 : fn());
    body.removeAttribute(LOCK_CLASSNAME);
  };
  if (!disable)
    init2();
  return {
    update({ disable: disable2 } = {}) {
      unsub();
      if (!disable2) {
        init2();
      }
    },
    destroy() {
      unsub();
    }
  };
}

// node_modules/radix-svelte/dist/internal/actions/dismissable.js
var dismissable = (node, params) => {
  let onPointerDownDismiss;
  let onEscapeKeyDown;
  let onDismiss;
  const handleDismiss = (event) => {
    if (event instanceof KeyboardEvent && event.key === "Escape") {
      handleAndDispatchCustomEvent("escDismiss", onEscapeKeyDown, {
        originalEvent: event,
        preventDefault: () => event.preventDefault()
      });
      if (!event.defaultPrevented) {
        onDismiss == null ? void 0 : onDismiss();
      }
    }
    if (event instanceof MouseEvent && !node.contains(event.target)) {
      handleAndDispatchCustomEvent("pointerDownDismiss", onPointerDownDismiss, {
        originalEvent: event,
        preventDefault: () => event.preventDefault()
      });
      if (!event.defaultPrevented) {
        onDismiss == null ? void 0 : onDismiss();
      }
    }
  };
  const update = (params2) => {
    document.removeEventListener("keydown", handleDismiss);
    document.removeEventListener("click", handleDismiss);
    if (params2 == null ? void 0 : params2.disable)
      return;
    onPointerDownDismiss = params2 == null ? void 0 : params2.onPointerDownOutside;
    onEscapeKeyDown = params2 == null ? void 0 : params2.onEscapeKeyDown;
    onDismiss = params2 == null ? void 0 : params2.onDismiss;
    document.addEventListener("keydown", handleDismiss);
    document.addEventListener("click", handleDismiss);
  };
  sleep(1).then(() => {
    update(params);
  });
  return {
    update,
    destroy() {
      document.removeEventListener("keydown", handleDismiss);
      document.removeEventListener("click", handleDismiss);
    }
  };
};
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// node_modules/radix-svelte/dist/internal/actions/focusTrap.js
function getFocusableElements(container) {
  const elements = Array.from(container.querySelectorAll('a, button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])'));
  return elements.filter((el) => !(el == null ? void 0 : el.disabled));
}
var getParams = (params) => {
  return {
    disable: false,
    autofocus: true,
    ...params
  };
};
var focusTrap = (container, params) => {
  const handleFocusIn = (event) => {
    if (!container.contains(event.target)) {
      container.focus();
    }
  };
  const handleKeyDown = (event) => {
    if (event.key === "Tab") {
      event.preventDefault();
      const focusableElements = getFocusableElements(container);
      if (focusableElements.length === 0) {
        return;
      }
      const currentIndex = focusableElements.indexOf(document.activeElement);
      let nextIndex = 0;
      if (event.shiftKey) {
        nextIndex = currentIndex <= 0 ? focusableElements.length - 1 : currentIndex - 1;
      } else {
        nextIndex = currentIndex >= focusableElements.length - 1 ? 0 : currentIndex + 1;
      }
      focusableElements[nextIndex].focus();
    }
  };
  const update = (newParams) => {
    const params2 = getParams(newParams);
    document.removeEventListener("focusin", handleFocusIn);
    container.removeEventListener("keydown", handleKeyDown);
    if (params2 == null ? void 0 : params2.disable)
      return;
    if (params2 == null ? void 0 : params2.autofocus) {
      const focusableElements = getFocusableElements(container);
      if (focusableElements.length > 0) {
        tick().then(() => {
          if (typeof params2.autofocus === "boolean") {
            focusableElements[0].focus();
          } else if (focusableElements.includes(params2.autofocus)) {
            params2.autofocus.focus();
          }
        });
      }
    }
    document.addEventListener("focusin", handleFocusIn);
    container.addEventListener("keydown", handleKeyDown);
    container.setAttribute("tabindex", "-1");
  };
  update(params);
  return {
    update,
    destroy() {
      document.removeEventListener("focusin", handleFocusIn);
      container.removeEventListener("keydown", handleKeyDown);
    }
  };
};

// node_modules/radix-svelte/dist/components/Dialog/content.svelte
var file26 = "node_modules/radix-svelte/dist/components/Dialog/content.svelte";
function create_fragment34(ctx) {
  let div;
  let div_id_value;
  let div_aria_labelledby_value;
  let div_aria_describedby_value;
  let div_data_state_value;
  let focusTrap_action;
  let dismissable_action;
  let removeScroll_action;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div_levels = [
    { role: "dialog" },
    /*$$restProps*/
    ctx[5],
    {
      id: div_id_value = /*$rootCtx*/
      ctx[2].contentId
    },
    {
      "aria-labelledby": div_aria_labelledby_value = /*$rootCtx*/
      ctx[2].titleId
    },
    {
      "aria-describedby": div_aria_describedby_value = /*$rootCtx*/
      ctx[2].descriptionId
    },
    {
      "data-state": div_data_state_value = getDataState(
        /*$rootCtx*/
        ctx[2].open
      )
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        role: true,
        id: true,
        "aria-labelledby": true,
        "aria-describedby": true,
        "data-state": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file26, 22, 0, 811);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(focusTrap_action = focusTrap.call(null, div, {
            disable: !/*$rootCtx*/
            ctx[2].modal,
            autofocus: (
              /*openAutoFocus*/
              ctx[0]
            )
          })),
          action_destroyer(dismissable_action = dismissable.call(null, div, {
            onPointerDownOutside: (
              /*dismissable_function*/
              ctx[9]
            ),
            onEscapeKeyDown: (
              /*dismissable_function_1*/
              ctx[10]
            ),
            onDismiss: (
              /*dismissable_function_2*/
              ctx[11]
            )
          })),
          action_destroyer(removeScroll_action = removeScroll.call(null, div, { disable: !/*$rootCtx*/
          ctx[2].modal })),
          action_destroyer(useActions_action = useActions.call(
            null,
            div,
            /*use*/
            ctx[1] ?? []
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { role: "dialog" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        (!current || dirty & /*$rootCtx*/
        4 && div_id_value !== (div_id_value = /*$rootCtx*/
        ctx2[2].contentId)) && { id: div_id_value },
        (!current || dirty & /*$rootCtx*/
        4 && div_aria_labelledby_value !== (div_aria_labelledby_value = /*$rootCtx*/
        ctx2[2].titleId)) && {
          "aria-labelledby": div_aria_labelledby_value
        },
        (!current || dirty & /*$rootCtx*/
        4 && div_aria_describedby_value !== (div_aria_describedby_value = /*$rootCtx*/
        ctx2[2].descriptionId)) && {
          "aria-describedby": div_aria_describedby_value
        },
        (!current || dirty & /*$rootCtx*/
        4 && div_data_state_value !== (div_data_state_value = getDataState(
          /*$rootCtx*/
          ctx2[2].open
        ))) && { "data-state": div_data_state_value }
      ]));
      if (focusTrap_action && is_function(focusTrap_action.update) && dirty & /*$rootCtx, openAutoFocus*/
      5)
        focusTrap_action.update.call(null, {
          disable: !/*$rootCtx*/
          ctx2[2].modal,
          autofocus: (
            /*openAutoFocus*/
            ctx2[0]
          )
        });
      if (dismissable_action && is_function(dismissable_action.update) && dirty & /*$rootCtx*/
      4)
        dismissable_action.update.call(null, {
          onPointerDownOutside: (
            /*dismissable_function*/
            ctx2[9]
          ),
          onEscapeKeyDown: (
            /*dismissable_function_1*/
            ctx2[10]
          ),
          onDismiss: (
            /*dismissable_function_2*/
            ctx2[11]
          )
        });
      if (removeScroll_action && is_function(removeScroll_action.update) && dirty & /*$rootCtx*/
      4)
        removeScroll_action.update.call(null, { disable: !/*$rootCtx*/
        ctx2[2].modal });
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      2)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[1] ?? []
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  const omit_props_names = ["openAutoFocus", "closeAutoFocus", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Content", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { openAutoFocus = true } = $$props;
  let { closeAutoFocus = true } = $$props;
  let { use = [] } = $$props;
  const rootCtx = getDialogRootContext();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value) => $$invalidate(2, $rootCtx = value));
  const dismissable_function = (event) => {
    dispatch("pointerDownOutside", event.detail);
  };
  const dismissable_function_1 = (event) => {
    dispatch("escapeKeyDown", event.detail);
  };
  const dismissable_function_2 = () => {
    set_store_value(rootCtx, $rootCtx.open = false, $rootCtx);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("openAutoFocus" in $$new_props)
      $$invalidate(0, openAutoFocus = $$new_props.openAutoFocus);
    if ("closeAutoFocus" in $$new_props)
      $$invalidate(6, closeAutoFocus = $$new_props.closeAutoFocus);
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    focusTrap,
    dismissable,
    removeScroll,
    focus,
    useActions,
    createEventDispatcher,
    tick,
    getDataState,
    getDialogRootContext,
    dispatch,
    openAutoFocus,
    closeAutoFocus,
    use,
    rootCtx,
    $rootCtx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("openAutoFocus" in $$props)
      $$invalidate(0, openAutoFocus = $$new_props.openAutoFocus);
    if ("closeAutoFocus" in $$props)
      $$invalidate(6, closeAutoFocus = $$new_props.closeAutoFocus);
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$rootCtx, closeAutoFocus*/
    68) {
      $:
        if (!$rootCtx.open && $rootCtx.triggeredId && closeAutoFocus) {
          tick().then(() => {
            focus(`#${$rootCtx.triggeredId}`);
            set_store_value(rootCtx, $rootCtx.triggeredId = null, $rootCtx);
          });
        }
    }
  };
  return [
    openAutoFocus,
    use,
    $rootCtx,
    dispatch,
    rootCtx,
    $$restProps,
    closeAutoFocus,
    $$scope,
    slots,
    dismissable_function,
    dismissable_function_1,
    dismissable_function_2
  ];
}
var Content4 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, {
      openAutoFocus: 0,
      closeAutoFocus: 6,
      use: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Content",
      options,
      id: create_fragment34.name
    });
  }
  get openAutoFocus() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set openAutoFocus(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeAutoFocus() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeAutoFocus(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var content_default4 = Content4;

// node_modules/radix-svelte/dist/components/Dialog/close.svelte
var file27 = "node_modules/radix-svelte/dist/components/Dialog/close.svelte";
function create_fragment35(ctx) {
  let button;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let button_levels = [
    /*$$restProps*/
    ctx[3]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {});
      var button_nodes = children(button);
      if (default_slot)
        default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file27, 8, 0, 223);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useActions_action = useActions.call(
            null,
            button,
            /*use*/
            ctx[0] ?? []
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [dirty & /*$$restProps*/
      8 && /*$$restProps*/
      ctx2[3]]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0] ?? []
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  const omit_props_names = ["use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Close", slots, ["default"]);
  let { use = [] } = $$props;
  const rootCtx = getDialogRootContext();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value) => $$invalidate(1, $rootCtx = value));
  const click_handler = () => {
    set_store_value(rootCtx, $rootCtx.open = false, $rootCtx);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useActions,
    getDialogRootContext,
    use,
    rootCtx,
    $rootCtx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [use, $rootCtx, rootCtx, $$restProps, $$scope, slots, click_handler];
}
var Close = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, { use: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Close",
      options,
      id: create_fragment35.name
    });
  }
  get use() {
    throw new Error("<Close>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Close>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var close_default = Close;

// node_modules/radix-svelte/dist/components/Dialog/overlay.svelte
var file28 = "node_modules/radix-svelte/dist/components/Dialog/overlay.svelte";
function create_if_block6(ctx) {
  let div;
  let div_data_state_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    {
      "data-state": div_data_state_value = getDataState(
        /*$rootCtx*/
        ctx[0].open
      )
    },
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "data-state": true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file28, 9, 1, 236);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*$rootCtx*/
        1 && div_data_state_value !== (div_data_state_value = getDataState(
          /*$rootCtx*/
          ctx2[0].open
        ))) && { "data-state": div_data_state_value },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(9:0) {#if $rootCtx.modal}",
    ctx
  });
  return block;
}
function create_fragment36(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$rootCtx*/
    ctx[0].modal && create_if_block6(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$rootCtx*/
        ctx2[0].modal
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$rootCtx*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Overlay", slots, ["default"]);
  "use strict";
  const rootCtx = getDialogRootContext();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value) => $$invalidate(0, $rootCtx = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getDataState,
    getDialogRootContext,
    rootCtx,
    $rootCtx
  });
  return [$rootCtx, rootCtx, $$restProps, $$scope, slots];
}
var Overlay = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Overlay",
      options,
      id: create_fragment36.name
    });
  }
};
var overlay_default = Overlay;

// node_modules/radix-svelte/dist/components/Dialog/title.svelte
var file29 = "node_modules/radix-svelte/dist/components/Dialog/title.svelte";
function create_fragment37(ctx) {
  let h2;
  let h2_id_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let h2_levels = [
    {
      id: h2_id_value = /*$rootCtx*/
      ctx[0].titleId
    },
    /*$$restProps*/
    ctx[2]
  ];
  let h2_data = {};
  for (let i = 0; i < h2_levels.length; i += 1) {
    h2_data = assign(h2_data, h2_levels[i]);
  }
  const block = {
    c: function create() {
      h2 = element("h2");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h2 = claim_element(nodes, "H2", { id: true });
      var h2_nodes = children(h2);
      if (default_slot)
        default_slot.l(h2_nodes);
      h2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(h2, h2_data);
      add_location(h2, file29, 7, 0, 163);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h2, anchor);
      if (default_slot) {
        default_slot.m(h2, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h2, h2_data = get_spread_update(h2_levels, [
        (!current || dirty & /*$rootCtx*/
        1 && h2_id_value !== (h2_id_value = /*$rootCtx*/
        ctx2[0].titleId)) && { id: h2_id_value },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance37($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Title", slots, ["default"]);
  "use strict";
  const rootCtx = getDialogRootContext();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value) => $$invalidate(0, $rootCtx = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ getDialogRootContext, rootCtx, $rootCtx });
  return [$rootCtx, rootCtx, $$restProps, $$scope, slots];
}
var Title = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Title",
      options,
      id: create_fragment37.name
    });
  }
};
var title_default = Title;

// node_modules/radix-svelte/dist/components/Dialog/description.svelte
var file30 = "node_modules/radix-svelte/dist/components/Dialog/description.svelte";
function create_fragment38(ctx) {
  let p;
  let p_id_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let p_levels = [
    {
      id: p_id_value = /*$rootCtx*/
      ctx[0].descriptionId
    },
    /*$$restProps*/
    ctx[2]
  ];
  let p_data = {};
  for (let i = 0; i < p_levels.length; i += 1) {
    p_data = assign(p_data, p_levels[i]);
  }
  const block = {
    c: function create() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", { id: true });
      var p_nodes = children(p);
      if (default_slot)
        default_slot.l(p_nodes);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(p, p_data);
      add_location(p, file30, 7, 0, 163);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        (!current || dirty & /*$rootCtx*/
        1 && p_id_value !== (p_id_value = /*$rootCtx*/
        ctx2[0].descriptionId)) && { id: p_id_value },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Description", slots, ["default"]);
  "use strict";
  const rootCtx = getDialogRootContext();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value) => $$invalidate(0, $rootCtx = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ getDialogRootContext, rootCtx, $rootCtx });
  return [$rootCtx, rootCtx, $$restProps, $$scope, slots];
}
var Description = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Description",
      options,
      id: create_fragment38.name
    });
  }
};
var description_default = Description;

// node_modules/radix-svelte/dist/components/Dialog/index.js
var Dialog = {
  Root: root_default10,
  Portal: portal_default,
  Trigger: trigger_default3,
  Content: content_default4,
  Close: close_default,
  Overlay: overlay_default,
  Title: title_default,
  Description: description_default
};

// node_modules/radix-svelte/dist/components/Tabs/root.svelte
var file31 = "node_modules/radix-svelte/dist/components/Tabs/root.svelte";
function create_fragment39(ctx) {
  let div;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    { dir: (
      /*dir*/
      ctx[0]
    ) },
    {
      "data-orientation": (
        /*orientation*/
        ctx[1]
      )
    },
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { dir: true, "data-orientation": true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file31, 20, 0, 683);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          div,
          /*$$restProps*/
          ctx[2].use
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*dir*/
        1) && { dir: (
          /*dir*/
          ctx2[0]
        ) },
        (!current || dirty & /*orientation*/
        2) && {
          "data-orientation": (
            /*orientation*/
            ctx2[1]
          )
        },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      4)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[2].use
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var defaults9 = {
  value: void 0,
  activateOn: "focus",
  orientation: "horizontal",
  dir: "ltr"
};
var { getContext: getContext12, setContext: setContext12 } = reactiveContext(defaults9);
var getTabsRootContext = getContext12;
function instance39($$self, $$props, $$invalidate) {
  const omit_props_names = ["value", "dir", "orientation", "activateOn"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, ["default"]);
  let { value = defaults9.value } = $$props;
  let { dir = defaults9.dir } = $$props;
  let { orientation = defaults9.orientation } = $$props;
  let { activateOn = defaults9.activateOn } = $$props;
  const ctx = setContext12({ value: (v) => $$invalidate(3, value = v) });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(3, value = $$new_props.value);
    if ("dir" in $$new_props)
      $$invalidate(0, dir = $$new_props.dir);
    if ("orientation" in $$new_props)
      $$invalidate(1, orientation = $$new_props.orientation);
    if ("activateOn" in $$new_props)
      $$invalidate(4, activateOn = $$new_props.activateOn);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    reactiveContext,
    useActions,
    defaults: defaults9,
    getContext: getContext12,
    setContext: setContext12,
    getTabsRootContext,
    value,
    dir,
    orientation,
    activateOn,
    ctx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(3, value = $$new_props.value);
    if ("dir" in $$props)
      $$invalidate(0, dir = $$new_props.dir);
    if ("orientation" in $$props)
      $$invalidate(1, orientation = $$new_props.orientation);
    if ("activateOn" in $$props)
      $$invalidate(4, activateOn = $$new_props.activateOn);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value, activateOn, orientation, dir*/
    27) {
      $:
        ctx.update((old) => ({
          ...old,
          value,
          activateOn,
          orientation,
          dir
        }));
    }
  };
  return [dir, orientation, $$restProps, value, activateOn, $$scope, slots];
}
var Root13 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, {
      value: 3,
      dir: 0,
      orientation: 1,
      activateOn: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment39.name
    });
  }
  get value() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dir() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dir(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orientation() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activateOn() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activateOn(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var root_default13 = Root13;

// node_modules/radix-svelte/dist/components/Tabs/list.svelte
var file32 = "node_modules/radix-svelte/dist/components/Tabs/list.svelte";
function create_fragment40(ctx) {
  let div;
  let div_data_orientation_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    { role: "tablist" },
    {
      "data-orientation": div_data_orientation_value = /*$rootCtx*/
      ctx[0].orientation
    },
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { role: true, "data-orientation": true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file32, 44, 0, 1693);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          div,
          /*$$restProps*/
          ctx[2].use
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { role: "tablist" },
        (!current || dirty & /*$rootCtx*/
        1 && div_data_orientation_value !== (div_data_orientation_value = /*$rootCtx*/
        ctx2[0].orientation)) && {
          "data-orientation": div_data_orientation_value
        },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      4)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[2].use
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var triggerCollection = collectionContext();
var getTriggerCollection2 = triggerCollection.getContext;
function instance40($$self, $$props, $$invalidate) {
  let nextKey;
  let prevKey;
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("List", slots, ["default"]);
  "use strict";
  const rootCtx = getTabsRootContext();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value) => $$invalidate(0, $rootCtx = value));
  const triggerStore = triggerCollection.setContext();
  const listeners = /* @__PURE__ */ new Map();
  triggerStore.subscribe((triggers) => {
    const enabledTriggers = triggers.filter((t) => !t.dataset.disabled);
    triggers.forEach((trigger, index) => {
      const prevCallback = listeners.get(index);
      if (prevCallback) {
        trigger.removeEventListener("keydown", prevCallback);
      }
      const enabledIdx = enabledTriggers.indexOf(trigger);
      const listener = (e) => {
        var _a, _b;
        if (e.key === nextKey) {
          e.preventDefault();
          (_a = next(enabledTriggers, enabledIdx)) == null ? void 0 : _a.focus();
        } else if (e.key === prevKey) {
          e.preventDefault();
          (_b = prev(enabledTriggers, enabledIdx)) == null ? void 0 : _b.focus();
        }
      };
      listeners.set(index, listener);
      trigger.addEventListener("keydown", listener);
    });
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    next,
    prev,
    collectionContext,
    useActions,
    getTabsRootContext,
    triggerCollection,
    getTriggerCollection: getTriggerCollection2,
    rootCtx,
    triggerStore,
    listeners,
    prevKey,
    nextKey,
    $rootCtx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("prevKey" in $$props)
      prevKey = $$new_props.prevKey;
    if ("nextKey" in $$props)
      nextKey = $$new_props.nextKey;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$rootCtx*/
    1) {
      $:
        nextKey = {
          horizontal: $rootCtx.dir === "rtl" ? "ArrowLeft" : "ArrowRight",
          vertical: "ArrowDown"
        }[$rootCtx.orientation ?? "horizontal"];
    }
    if ($$self.$$.dirty & /*$rootCtx*/
    1) {
      $:
        prevKey = {
          horizontal: $rootCtx.dir === "rtl" ? "ArrowRight" : "ArrowLeft",
          vertical: "ArrowUp"
        }[$rootCtx.orientation ?? "horizontal"];
    }
  };
  return [$rootCtx, rootCtx, $$restProps, $$scope, slots];
}
var List = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "List",
      options,
      id: create_fragment40.name
    });
  }
};
var list_default = List;

// node_modules/radix-svelte/dist/components/Tabs/trigger.svelte
var file33 = "node_modules/radix-svelte/dist/components/Tabs/trigger.svelte";
function create_fragment41(ctx) {
  let button;
  let button_data_state_value;
  let button_data_orientation_value;
  let button_tabindex_value;
  let button_data_disabled_value;
  let useActions_action;
  let useCollection_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let button_levels = [
    {
      "data-state": button_data_state_value = /*selected*/
      ctx[3] ? "active" : "inactive"
    },
    {
      "data-orientation": button_data_orientation_value = /*$rootCtx*/
      ctx[2].orientation
    },
    { role: "tab" },
    {
      tabindex: button_tabindex_value = /*selected*/
      ctx[3] ? 0 : -1
    },
    { disabled: (
      /*disabled*/
      ctx[1]
    ) },
    {
      "data-disabled": button_data_disabled_value = /*disabled*/
      ctx[1] || void 0
    },
    /*$$restProps*/
    ctx[6]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        "data-state": true,
        "data-orientation": true,
        role: true,
        tabindex: true,
        "data-disabled": true
      });
      var button_nodes = children(button);
      if (default_slot)
        default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file33, 13, 0, 474);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "focus",
            /*focus_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useActions_action = useActions.call(
            null,
            button,
            /*$$restProps*/
            ctx[6].use
          )),
          action_destroyer(useCollection_action = useCollection.call(null, button, { collection: (
            /*triggerCollection*/
            ctx[5]
          ) }))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        (!current || dirty & /*selected*/
        8 && button_data_state_value !== (button_data_state_value = /*selected*/
        ctx2[3] ? "active" : "inactive")) && { "data-state": button_data_state_value },
        (!current || dirty & /*$rootCtx*/
        4 && button_data_orientation_value !== (button_data_orientation_value = /*$rootCtx*/
        ctx2[2].orientation)) && {
          "data-orientation": button_data_orientation_value
        },
        { role: "tab" },
        (!current || dirty & /*selected*/
        8 && button_tabindex_value !== (button_tabindex_value = /*selected*/
        ctx2[3] ? 0 : -1)) && { tabindex: button_tabindex_value },
        (!current || dirty & /*disabled*/
        2) && { disabled: (
          /*disabled*/
          ctx2[1]
        ) },
        (!current || dirty & /*disabled*/
        2 && button_data_disabled_value !== (button_data_disabled_value = /*disabled*/
        ctx2[1] || void 0)) && {
          "data-disabled": button_data_disabled_value
        },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      64)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[6].use
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props, $$invalidate) {
  let selected;
  const omit_props_names = ["value", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Trigger", slots, ["default"]);
  let { value } = $$props;
  let { disabled = false } = $$props;
  const rootCtx = getTabsRootContext();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value2) => $$invalidate(2, $rootCtx = value2));
  const triggerCollection2 = getTriggerCollection2();
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<Trigger> was created without expected prop 'value'");
    }
  });
  const click_handler = () => set_store_value(rootCtx, $rootCtx.value = value, $rootCtx);
  const focus_handler = () => {
    if ($rootCtx.activateOn === "focus") {
      set_store_value(rootCtx, $rootCtx.value = value, $rootCtx);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useCollection,
    useActions,
    getTriggerCollection: getTriggerCollection2,
    getTabsRootContext,
    value,
    disabled,
    rootCtx,
    triggerCollection: triggerCollection2,
    selected,
    $rootCtx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("selected" in $$props)
      $$invalidate(3, selected = $$new_props.selected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$rootCtx, value*/
    5) {
      $:
        $$invalidate(3, selected = $rootCtx.value === value);
    }
  };
  return [
    value,
    disabled,
    $rootCtx,
    selected,
    rootCtx,
    triggerCollection2,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    focus_handler
  ];
}
var Trigger4 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment41, safe_not_equal, { value: 0, disabled: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Trigger",
      options,
      id: create_fragment41.name
    });
  }
  get value() {
    throw new Error("<Trigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Trigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Trigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Trigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var trigger_default4 = Trigger4;

// node_modules/radix-svelte/dist/components/Tabs/content.svelte
var file34 = "node_modules/radix-svelte/dist/components/Tabs/content.svelte";
function create_if_block7(ctx) {
  let div;
  let div_data_state_value;
  let div_data_orientation_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[3],
    {
      "data-state": div_data_state_value = /*selected*/
      ctx[1] ? "active" : "inactive"
    },
    {
      "data-orientation": div_data_orientation_value = /*$rootCtx*/
      ctx[0].orientation
    },
    { role: "tabpanel" },
    { tabindex: "0" }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        "data-state": true,
        "data-orientation": true,
        role: true,
        tabindex: true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file34, 10, 1, 283);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          div,
          /*$$restProps*/
          ctx[3].use
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*selected*/
        2 && div_data_state_value !== (div_data_state_value = /*selected*/
        ctx2[1] ? "active" : "inactive")) && { "data-state": div_data_state_value },
        (!current || dirty & /*$rootCtx*/
        1 && div_data_orientation_value !== (div_data_orientation_value = /*$rootCtx*/
        ctx2[0].orientation)) && {
          "data-orientation": div_data_orientation_value
        },
        { role: "tabpanel" },
        { tabindex: "0" }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      8)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[3].use
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(10:0) {#if selected}",
    ctx
  });
  return block;
}
function create_fragment42(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*selected*/
    ctx[1] && create_if_block7(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*selected*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*selected*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props, $$invalidate) {
  let selected;
  const omit_props_names = ["value"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Content", slots, ["default"]);
  let { value } = $$props;
  const rootCtx = getTabsRootContext();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value2) => $$invalidate(0, $rootCtx = value2));
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<Content> was created without expected prop 'value'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(4, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useActions,
    getTabsRootContext,
    value,
    rootCtx,
    selected,
    $rootCtx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(4, value = $$new_props.value);
    if ("selected" in $$props)
      $$invalidate(1, selected = $$new_props.selected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$rootCtx, value*/
    17) {
      $:
        $$invalidate(1, selected = $rootCtx.value === value);
    }
  };
  return [$rootCtx, selected, rootCtx, $$restProps, value, $$scope, slots];
}
var Content5 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, { value: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Content",
      options,
      id: create_fragment42.name
    });
  }
  get value() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var content_default5 = Content5;

// node_modules/radix-svelte/dist/components/Tabs/index.js
var Tabs = {
  Root: root_default13,
  List: list_default,
  Trigger: trigger_default4,
  Content: content_default5
};

// node_modules/radix-svelte/dist/components/Avatar/root.svelte
var file35 = "node_modules/radix-svelte/dist/components/Avatar/root.svelte";
function create_fragment43(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  let span_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file35, 12, 0, 341);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          span,
          /*$$restProps*/
          ctx[0].use
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      1)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[0].use
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var { getContext: getContext13, setContext: setContext13 } = reactiveContext({ imageLoadingStatus: "idle" });
var getAvatarRootContext = getContext13;
function instance43($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, ["default"]);
  "use strict";
  setContext13();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    reactiveContext,
    useActions,
    getContext: getContext13,
    setContext: setContext13,
    getAvatarRootContext
  });
  return [$$restProps, $$scope, slots];
}
var Root14 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment43.name
    });
  }
};
var root_default14 = Root14;

// node_modules/radix-svelte/dist/internal/stores/isMounted.js
var isMountedStore = () => {
  const mounted = writable(false);
  onMount(() => {
    mounted.set(true);
    return () => {
      mounted.set(false);
    };
  });
  return mounted;
};

// node_modules/radix-svelte/dist/components/Avatar/image.svelte
var file36 = "node_modules/radix-svelte/dist/components/Avatar/image.svelte";
function create_if_block8(ctx) {
  let img;
  let img_src_value;
  let useActions_action;
  let mounted;
  let dispose;
  let img_levels = [
    { src: img_src_value = /*src*/
    ctx[0] },
    { alt: (
      /*alt*/
      ctx[1]
    ) },
    /*$$restProps*/
    ctx[5]
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", { src: true, alt: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(img, img_data);
      add_location(img, file36, 36, 1, 1135);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          img,
          /*$$restProps*/
          ctx[5].use
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & /*src*/
        1 && !src_url_equal(img.src, img_src_value = /*src*/
        ctx2[0]) && { src: img_src_value },
        dirty & /*alt*/
        2 && { alt: (
          /*alt*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      32)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[5].use
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(img);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(36:0) {#if $rootCtx.imageLoadingStatus === 'loaded'}",
    ctx
  });
  return block;
}
function create_fragment44(ctx) {
  let if_block_anchor;
  let if_block = (
    /*$rootCtx*/
    ctx[2].imageLoadingStatus === "loaded" && create_if_block8(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$rootCtx*/
        ctx2[2].imageLoadingStatus === "loaded"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block8(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self, $$props, $$invalidate) {
  const omit_props_names = ["src", "alt"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let $isMounted;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Image", slots, []);
  let { src = void 0 } = $$props;
  let { alt = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  const isMounted = isMountedStore();
  validate_store(isMounted, "isMounted");
  component_subscribe($$self, isMounted, (value) => $$invalidate(6, $isMounted = value));
  const rootCtx = getAvatarRootContext();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value) => $$invalidate(2, $rootCtx = value));
  function handleLoad(src2) {
    if (typeof window === "undefined")
      return;
    if (!src2) {
      set_store_value(rootCtx, $rootCtx.imageLoadingStatus = "error", $rootCtx);
      return;
    }
    const image = new window.Image();
    const updateStatus = (status) => () => {
      if (!$isMounted)
        return;
      set_store_value(rootCtx, $rootCtx.imageLoadingStatus = status, $rootCtx);
    };
    set_store_value(rootCtx, $rootCtx.imageLoadingStatus = "loading", $rootCtx);
    image.onload = updateStatus("loaded");
    image.onerror = updateStatus("error");
    image.src = src2;
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("src" in $$new_props)
      $$invalidate(0, src = $$new_props.src);
    if ("alt" in $$new_props)
      $$invalidate(1, alt = $$new_props.alt);
  };
  $$self.$capture_state = () => ({
    useActions,
    isMountedStore,
    getAvatarRootContext,
    createEventDispatcher,
    src,
    alt,
    dispatch,
    isMounted,
    rootCtx,
    handleLoad,
    $rootCtx,
    $isMounted
  });
  $$self.$inject_state = ($$new_props) => {
    if ("src" in $$props)
      $$invalidate(0, src = $$new_props.src);
    if ("alt" in $$props)
      $$invalidate(1, alt = $$new_props.alt);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$rootCtx*/
    4) {
      $:
        if ($rootCtx.imageLoadingStatus !== "idle") {
          dispatch("loadingStatusChange", $rootCtx.imageLoadingStatus);
        }
    }
    if ($$self.$$.dirty & /*src*/
    1) {
      $:
        handleLoad(src);
    }
  };
  return [src, alt, $rootCtx, isMounted, rootCtx, $$restProps];
}
var Image = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment44, safe_not_equal, { src: 0, alt: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Image",
      options,
      id: create_fragment44.name
    });
  }
  get src() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var image_default = Image;

// node_modules/radix-svelte/dist/components/Avatar/fallback.svelte
var file37 = "node_modules/radix-svelte/dist/components/Avatar/fallback.svelte";
function create_if_block9(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let span_levels = [
    /*$$restProps*/
    ctx[3]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file37, 21, 1, 512);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          span,
          /*$$restProps*/
          ctx[3].use
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [dirty & /*$$restProps*/
      8 && /*$$restProps*/
      ctx2[3]]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      8)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[3].use
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(21:0) {#if canRender && $rootCtx.imageLoadingStatus !== 'loaded'}",
    ctx
  });
  return block;
}
function create_fragment45(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*canRender*/
    ctx[0] && /*$rootCtx*/
    ctx[1].imageLoadingStatus !== "loaded" && create_if_block9(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*canRender*/
        ctx2[0] && /*$rootCtx*/
        ctx2[1].imageLoadingStatus !== "loaded"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*canRender, $rootCtx*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance45($$self, $$props, $$invalidate) {
  const omit_props_names = ["delayMs"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fallback", slots, ["default"]);
  let { delayMs = 0 } = $$props;
  let canRender = !delayMs;
  let timeout;
  const rootCtx = getAvatarRootContext();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value) => $$invalidate(1, $rootCtx = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("delayMs" in $$new_props)
      $$invalidate(4, delayMs = $$new_props.delayMs);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useActions,
    getAvatarRootContext,
    delayMs,
    canRender,
    timeout,
    rootCtx,
    $rootCtx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("delayMs" in $$props)
      $$invalidate(4, delayMs = $$new_props.delayMs);
    if ("canRender" in $$props)
      $$invalidate(0, canRender = $$new_props.canRender);
    if ("timeout" in $$props)
      $$invalidate(5, timeout = $$new_props.timeout);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*delayMs, timeout*/
    48) {
      $:
        if (delayMs) {
          if (timeout)
            clearTimeout(timeout);
          $$invalidate(5, timeout = setTimeout(
            () => {
              $$invalidate(0, canRender = true);
            },
            delayMs
          ));
        } else {
          $$invalidate(0, canRender = true);
        }
    }
  };
  return [canRender, $rootCtx, rootCtx, $$restProps, delayMs, timeout, $$scope, slots];
}
var Fallback = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance45, create_fragment45, safe_not_equal, { delayMs: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fallback",
      options,
      id: create_fragment45.name
    });
  }
  get delayMs() {
    throw new Error("<Fallback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set delayMs(value) {
    throw new Error("<Fallback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var fallback_default = Fallback;

// node_modules/radix-svelte/dist/components/Avatar/index.js
var Avatar = {
  Root: root_default14,
  Image: image_default,
  Fallback: fallback_default
};

// node_modules/radix-svelte/dist/components/ToggleGroup/root.svelte
var file38 = "node_modules/radix-svelte/dist/components/ToggleGroup/root.svelte";
function create_fragment46(ctx) {
  let div;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let div_levels = [
    { role: (
      /*role*/
      ctx[2]
    ) },
    { dir: (
      /*dir*/
      ctx[1]
    ) },
    /*$$restProps*/
    ctx[3],
    {
      "data-orientation": (
        /*orientation*/
        ctx[0]
      )
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        role: true,
        dir: true,
        "data-orientation": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file38, 63, 0, 2227);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          div,
          /*$$restProps*/
          ctx[3].use
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*role*/
        4) && { role: (
          /*role*/
          ctx2[2]
        ) },
        (!current || dirty & /*dir*/
        2) && { dir: (
          /*dir*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*orientation*/
        1) && {
          "data-orientation": (
            /*orientation*/
            ctx2[0]
          )
        }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*$$restProps*/
      8)
        useActions_action.update.call(
          null,
          /*$$restProps*/
          ctx2[3].use
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var defaults10 = {
  type: "single",
  orientation: "horizontal",
  dir: "ltr",
  loop: true,
  rovingFocus: true,
  disabled: false,
  value: null
};
var { getContext: getContext14, setContext: setContext14 } = reactiveContext(defaults10);
var getToggleGroupRootContext = getContext14;
var itemCollection = collectionContext();
var getToggleGroupItemCollection = itemCollection.getContext;
function instance46($$self, $$props, $$invalidate) {
  let nextKey;
  let prevKey;
  const omit_props_names = ["type", "value", "rovingFocus", "orientation", "dir", "loop", "disabled", "role"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, ["default"]);
  let { type = defaults10.type } = $$props;
  let { value = null } = $$props;
  let { rovingFocus = defaults10.rovingFocus } = $$props;
  let { orientation = defaults10.orientation } = $$props;
  let { dir = defaults10.dir } = $$props;
  let { loop = defaults10.loop } = $$props;
  let { disabled = defaults10.disabled } = $$props;
  let { role = "group" } = $$props;
  const ctx = setContext14({ value: (v) => $$invalidate(4, value = v) });
  const itemStore = itemCollection.setContext();
  const listeners = /* @__PURE__ */ new Map();
  itemStore.subscribe((items) => {
    items.forEach((item, index) => {
      const prevCallback = listeners.get(index);
      if (prevCallback) {
        item.removeEventListener("keydown", prevCallback);
      }
      const enabledItems = items.filter((i) => i.dataset.disabled === void 0);
      const enabledIdx = enabledItems.indexOf(item);
      const listener = (e) => {
        var _a, _b;
        if (!rovingFocus)
          return;
        if (e.key === nextKey) {
          e.preventDefault();
          (_a = next(enabledItems, enabledIdx, loop)) == null ? void 0 : _a.focus();
        } else if (e.key === prevKey) {
          e.preventDefault();
          (_b = prev(enabledItems, enabledIdx, loop)) == null ? void 0 : _b.focus();
        }
      };
      listeners.set(index, listener);
      item.addEventListener("keydown", listener);
    });
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("type" in $$new_props)
      $$invalidate(5, type = $$new_props.type);
    if ("value" in $$new_props)
      $$invalidate(4, value = $$new_props.value);
    if ("rovingFocus" in $$new_props)
      $$invalidate(6, rovingFocus = $$new_props.rovingFocus);
    if ("orientation" in $$new_props)
      $$invalidate(0, orientation = $$new_props.orientation);
    if ("dir" in $$new_props)
      $$invalidate(1, dir = $$new_props.dir);
    if ("loop" in $$new_props)
      $$invalidate(7, loop = $$new_props.loop);
    if ("disabled" in $$new_props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("role" in $$new_props)
      $$invalidate(2, role = $$new_props.role);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    collectionContext,
    next,
    prev,
    useActions,
    reactiveContext,
    defaults: defaults10,
    getContext: getContext14,
    setContext: setContext14,
    getToggleGroupRootContext,
    itemCollection,
    getToggleGroupItemCollection,
    type,
    value,
    rovingFocus,
    orientation,
    dir,
    loop,
    disabled,
    role,
    ctx,
    itemStore,
    listeners,
    prevKey,
    nextKey
  });
  $$self.$inject_state = ($$new_props) => {
    if ("type" in $$props)
      $$invalidate(5, type = $$new_props.type);
    if ("value" in $$props)
      $$invalidate(4, value = $$new_props.value);
    if ("rovingFocus" in $$props)
      $$invalidate(6, rovingFocus = $$new_props.rovingFocus);
    if ("orientation" in $$props)
      $$invalidate(0, orientation = $$new_props.orientation);
    if ("dir" in $$props)
      $$invalidate(1, dir = $$new_props.dir);
    if ("loop" in $$props)
      $$invalidate(7, loop = $$new_props.loop);
    if ("disabled" in $$props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("role" in $$props)
      $$invalidate(2, role = $$new_props.role);
    if ("prevKey" in $$props)
      prevKey = $$new_props.prevKey;
    if ("nextKey" in $$props)
      nextKey = $$new_props.nextKey;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*type, orientation, dir, loop, rovingFocus, disabled, value*/
    499) {
      $:
        ctx.set({
          type,
          orientation,
          dir,
          loop,
          rovingFocus,
          disabled,
          value
        });
    }
    if ($$self.$$.dirty & /*dir, orientation*/
    3) {
      $:
        nextKey = {
          horizontal: dir === "rtl" ? "ArrowLeft" : "ArrowRight",
          vertical: "ArrowDown"
        }[orientation ?? "horizontal"];
    }
    if ($$self.$$.dirty & /*dir, orientation*/
    3) {
      $:
        prevKey = {
          horizontal: dir === "rtl" ? "ArrowRight" : "ArrowLeft",
          vertical: "ArrowUp"
        }[orientation ?? "horizontal"];
    }
  };
  return [
    orientation,
    dir,
    role,
    $$restProps,
    value,
    type,
    rovingFocus,
    loop,
    disabled,
    $$scope,
    slots
  ];
}
var Root15 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance46, create_fragment46, safe_not_equal, {
      type: 5,
      value: 4,
      rovingFocus: 6,
      orientation: 0,
      dir: 1,
      loop: 7,
      disabled: 8,
      role: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment46.name
    });
  }
  get type() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rovingFocus() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rovingFocus(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orientation() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dir() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dir(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var root_default15 = Root15;

// node_modules/radix-svelte/dist/components/ToggleGroup/item.svelte
function create_default_slot8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: "(23:0) <Toggle.Root  {...$$restProps}  use={[   ...(use ?? []),   [    useCollection,    {     collection: itemCollection,    },   ],  ]}  disabled={$rootCtx.disabled || disabled}  pressed={Array.isArray($rootCtx.value)   ? $rootCtx.value.includes(value)   : $rootCtx.value === value}  on:change={(e) => handleChange(e)}  {...{ ['data-orientation']: $rootCtx.orientation }} >",
    ctx
  });
  return block;
}
function create_fragment47(ctx) {
  let toggle_root;
  let current;
  const toggle_root_spread_levels = [
    /*$$restProps*/
    ctx[7],
    {
      use: [
        .../*use*/
        ctx[0] ?? [],
        [useCollection, { collection: (
          /*itemCollection*/
          ctx[5]
        ) }]
      ]
    },
    {
      disabled: (
        /*$rootCtx*/
        ctx[3].disabled || /*disabled*/
        ctx[2]
      )
    },
    {
      pressed: Array.isArray(
        /*$rootCtx*/
        ctx[3].value
      ) ? (
        /*$rootCtx*/
        ctx[3].value.includes(
          /*value*/
          ctx[1]
        )
      ) : (
        /*$rootCtx*/
        ctx[3].value === /*value*/
        ctx[1]
      )
    },
    {
      ["data-orientation"]: (
        /*$rootCtx*/
        ctx[3].orientation
      )
    }
  ];
  let toggle_root_props = {
    $$slots: { default: [create_default_slot8] },
    $$scope: { ctx }
  };
  for (let i = 0; i < toggle_root_spread_levels.length; i += 1) {
    toggle_root_props = assign(toggle_root_props, toggle_root_spread_levels[i]);
  }
  toggle_root = new Toggle.Root({ props: toggle_root_props, $$inline: true });
  toggle_root.$on(
    "change",
    /*change_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(toggle_root.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(toggle_root.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(toggle_root, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const toggle_root_changes = dirty & /*$$restProps, use, useCollection, itemCollection, $rootCtx, disabled, Array, value*/
      175 ? get_spread_update(toggle_root_spread_levels, [
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx2[7]
        ),
        dirty & /*use, useCollection, itemCollection*/
        33 && {
          use: [
            .../*use*/
            ctx2[0] ?? [],
            [useCollection, { collection: (
              /*itemCollection*/
              ctx2[5]
            ) }]
          ]
        },
        dirty & /*$rootCtx, disabled*/
        12 && {
          disabled: (
            /*$rootCtx*/
            ctx2[3].disabled || /*disabled*/
            ctx2[2]
          )
        },
        dirty & /*Array, $rootCtx, value*/
        10 && {
          pressed: Array.isArray(
            /*$rootCtx*/
            ctx2[3].value
          ) ? (
            /*$rootCtx*/
            ctx2[3].value.includes(
              /*value*/
              ctx2[1]
            )
          ) : (
            /*$rootCtx*/
            ctx2[3].value === /*value*/
            ctx2[1]
          )
        },
        dirty & /*$rootCtx*/
        8 && {
          ["data-orientation"]: (
            /*$rootCtx*/
            ctx2[3].orientation
          )
        }
      ]) : {};
      if (dirty & /*$$scope*/
      1024) {
        toggle_root_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toggle_root.$set(toggle_root_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toggle_root.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toggle_root.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(toggle_root, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance47($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "value", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Item", slots, ["default"]);
  let { use = [] } = $$props;
  let { value } = $$props;
  let { disabled = false } = $$props;
  const rootCtx = getToggleGroupRootContext();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value2) => $$invalidate(3, $rootCtx = value2));
  const itemCollection3 = getToggleGroupItemCollection();
  function handleChange(e) {
    const pressed = e.detail;
    if ($rootCtx.type === "single") {
      set_store_value(rootCtx, $rootCtx.value = pressed ? value : null, $rootCtx);
    } else {
      const values = Array.isArray($rootCtx.value) ? $rootCtx.value : [];
      set_store_value(
        rootCtx,
        $rootCtx.value = pressed ? [...values, value] : values.filter((v) => v !== value),
        $rootCtx
      );
    }
  }
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<Item> was created without expected prop 'value'");
    }
  });
  const change_handler = (e) => handleChange(e);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Toggle,
    useCollection,
    getToggleGroupItemCollection,
    getToggleGroupRootContext,
    use,
    value,
    disabled,
    rootCtx,
    itemCollection: itemCollection3,
    handleChange,
    $rootCtx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
    if ("disabled" in $$props)
      $$invalidate(2, disabled = $$new_props.disabled);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    value,
    disabled,
    $rootCtx,
    rootCtx,
    itemCollection3,
    handleChange,
    $$restProps,
    slots,
    change_handler,
    $$scope
  ];
}
var Item2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance47, create_fragment47, safe_not_equal, { use: 0, value: 1, disabled: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Item",
      options,
      id: create_fragment47.name
    });
  }
  get use() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var item_default2 = Item2;

// node_modules/radix-svelte/dist/components/ToggleGroup/index.js
var ToggleGroup = {
  Root: root_default15,
  Item: item_default2
};

// node_modules/radix-svelte/dist/components/Label/root.svelte
var file39 = "node_modules/radix-svelte/dist/components/Label/root.svelte";
function create_fragment48(ctx) {
  let label;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let label_levels = [
    /*$$restProps*/
    ctx[2]
  ];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", {});
      var label_nodes = children(label);
      if (default_slot)
        default_slot.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(label, label_data);
      add_location(label, file39, 7, 0, 127);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      ctx[6](label);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          label,
          "mousedown",
          /*mousedown_handler*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [dirty & /*$$restProps*/
      4 && /*$$restProps*/
      ctx2[2]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[6](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance48($$self, $$props, $$invalidate) {
  const omit_props_names = ["onMouseDown", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, ["default"]);
  let { onMouseDown = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  const mousedown_handler = (event) => {
    onMouseDown == null ? void 0 : onMouseDown(event);
    if (!event.defaultPrevented && event.detail > 1) {
      event.preventDefault();
    }
  };
  function label_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("onMouseDown" in $$new_props)
      $$invalidate(1, onMouseDown = $$new_props.onMouseDown);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ onMouseDown, ref });
  $$self.$inject_state = ($$new_props) => {
    if ("onMouseDown" in $$props)
      $$invalidate(1, onMouseDown = $$new_props.onMouseDown);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ref,
    onMouseDown,
    $$restProps,
    $$scope,
    slots,
    mousedown_handler,
    label_binding
  ];
}
var Root16 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance48, create_fragment48, safe_not_equal, { onMouseDown: 1, ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment48.name
    });
  }
  get onMouseDown() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseDown(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var root_default16 = Root16;

// node_modules/radix-svelte/dist/components/Label/index.js
var Label = {
  Root: root_default16
};

// node_modules/radix-svelte/dist/components/RadioGroup/root.svelte
var file40 = "node_modules/radix-svelte/dist/components/RadioGroup/root.svelte";
function create_fragment49(ctx) {
  let div;
  let div_data_disabled_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let div_levels = [
    { dir: (
      /*dir*/
      ctx[1]
    ) },
    { role: "radiogroup" },
    { tabindex: "0" },
    {
      "data-disabled": div_data_disabled_value = /*disabled*/
      ctx[2] ? "" : void 0
    },
    {
      "data-orientation": (
        /*orientation*/
        ctx[4]
      )
    },
    {
      "aria-orientation": (
        /*orientation*/
        ctx[4]
      )
    },
    { "aria-required": (
      /*required*/
      ctx[3]
    ) },
    /*$$restProps*/
    ctx[5]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        dir: true,
        role: true,
        tabindex: true,
        "data-disabled": true,
        "data-orientation": true,
        "aria-orientation": true,
        "aria-required": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file40, 64, 0, 2323);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          div,
          /*use*/
          ctx[0] ?? []
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*dir*/
        2) && { dir: (
          /*dir*/
          ctx2[1]
        ) },
        { role: "radiogroup" },
        { tabindex: "0" },
        (!current || dirty & /*disabled*/
        4 && div_data_disabled_value !== (div_data_disabled_value = /*disabled*/
        ctx2[2] ? "" : void 0)) && { "data-disabled": div_data_disabled_value },
        (!current || dirty & /*orientation*/
        16) && {
          "data-orientation": (
            /*orientation*/
            ctx2[4]
          )
        },
        (!current || dirty & /*orientation*/
        16) && {
          "aria-orientation": (
            /*orientation*/
            ctx2[4]
          )
        },
        (!current || dirty & /*required*/
        8) && { "aria-required": (
          /*required*/
          ctx2[3]
        ) },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0] ?? []
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment49.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var defaults11 = {
  value: void 0,
  disabled: false,
  required: false,
  name: void 0
};
var { getContext: getContext15, setContext: setContext15 } = reactiveContext(defaults11);
var getRadioGroupRootContext = getContext15;
var itemCollection2 = collectionContext();
var getRadioGroupItemCollection = itemCollection2.getContext;
function instance49($$self, $$props, $$invalidate) {
  let nextKeys;
  let prevKeys;
  const omit_props_names = ["use", "value", "dir", "disabled", "required", "orientation", "name", "loop"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, ["default"]);
  let { use = [] } = $$props;
  let { value = defaults11.value } = $$props;
  let { dir = "ltr" } = $$props;
  let { disabled = defaults11.disabled } = $$props;
  let { required = defaults11.required } = $$props;
  let { orientation = void 0 } = $$props;
  let { name = defaults11.name } = $$props;
  let { loop = true } = $$props;
  const ctx = setContext15({ value: (v) => $$invalidate(6, value = v) });
  const itemStore = itemCollection2.setContext();
  const listeners = /* @__PURE__ */ new Map();
  itemStore.subscribe((items) => {
    items.forEach((item, index) => {
      const prevCallback = listeners.get(index);
      if (prevCallback) {
        item.removeEventListener("keydown", prevCallback);
      }
      const listener = (e) => {
        const enabledItems = items.filter((i) => i.dataset.disabled === void 0);
        const enabledIdx = enabledItems.indexOf(item);
        if (nextKeys.includes(e.key)) {
          e.preventDefault();
          const el = next(enabledItems, enabledIdx, loop);
          el == null ? void 0 : el.focus();
          el == null ? void 0 : el.click();
        } else if (prevKeys.includes(e.key)) {
          e.preventDefault();
          const el = prev(enabledItems, enabledIdx, loop);
          el == null ? void 0 : el.focus();
          el == null ? void 0 : el.click();
        }
      };
      listeners.set(index, listener);
      item.addEventListener("keydown", listener);
    });
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("value" in $$new_props)
      $$invalidate(6, value = $$new_props.value);
    if ("dir" in $$new_props)
      $$invalidate(1, dir = $$new_props.dir);
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("required" in $$new_props)
      $$invalidate(3, required = $$new_props.required);
    if ("orientation" in $$new_props)
      $$invalidate(4, orientation = $$new_props.orientation);
    if ("name" in $$new_props)
      $$invalidate(7, name = $$new_props.name);
    if ("loop" in $$new_props)
      $$invalidate(8, loop = $$new_props.loop);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    collectionContext,
    next,
    prev,
    useActions,
    reactiveContext,
    defaults: defaults11,
    getContext: getContext15,
    setContext: setContext15,
    getRadioGroupRootContext,
    itemCollection: itemCollection2,
    getRadioGroupItemCollection,
    use,
    value,
    dir,
    disabled,
    required,
    orientation,
    name,
    loop,
    ctx,
    itemStore,
    listeners,
    prevKeys,
    nextKeys
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("value" in $$props)
      $$invalidate(6, value = $$new_props.value);
    if ("dir" in $$props)
      $$invalidate(1, dir = $$new_props.dir);
    if ("disabled" in $$props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("required" in $$props)
      $$invalidate(3, required = $$new_props.required);
    if ("orientation" in $$props)
      $$invalidate(4, orientation = $$new_props.orientation);
    if ("name" in $$props)
      $$invalidate(7, name = $$new_props.name);
    if ("loop" in $$props)
      $$invalidate(8, loop = $$new_props.loop);
    if ("prevKeys" in $$props)
      prevKeys = $$new_props.prevKeys;
    if ("nextKeys" in $$props)
      nextKeys = $$new_props.nextKeys;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value, disabled, required, name*/
    204) {
      $:
        ctx.set({ value, disabled, required, name });
    }
    if ($$self.$$.dirty & /*dir, orientation*/
    18) {
      $:
        nextKeys = {
          horizontal: [dir === "rtl" ? "ArrowLeft" : "ArrowRight"],
          vertical: ["ArrowDown"],
          both: ["ArrowDown", dir === "rtl" ? "ArrowLeft" : "ArrowRight"]
        }[orientation || "both"];
    }
    if ($$self.$$.dirty & /*dir, orientation*/
    18) {
      $:
        prevKeys = {
          horizontal: [dir === "rtl" ? "ArrowRight" : "ArrowLeft"],
          vertical: ["ArrowUp"],
          both: ["ArrowUp", dir === "rtl" ? "ArrowRight" : "ArrowLeft"]
        }[orientation || "both"];
    }
  };
  return [
    use,
    dir,
    disabled,
    required,
    orientation,
    $$restProps,
    value,
    name,
    loop,
    $$scope,
    slots
  ];
}
var Root17 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance49, create_fragment49, safe_not_equal, {
      use: 0,
      value: 6,
      dir: 1,
      disabled: 2,
      required: 3,
      orientation: 4,
      name: 7,
      loop: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment49.name
    });
  }
  get use() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dir() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dir(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orientation() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var root_default17 = Root17;

// node_modules/radix-svelte/dist/components/RadioGroup/item.svelte
var file41 = "node_modules/radix-svelte/dist/components/RadioGroup/item.svelte";
function create_fragment50(ctx) {
  let button;
  let button_data_state_value;
  let button_data_disabled_value;
  let button_disabled_value;
  let useActions_action;
  let t;
  let input;
  let input_tabindex_value;
  let input_name_value;
  let input_required_value;
  let input_disabled_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let button_levels = [
    { type: "button" },
    { role: "radio" },
    { "aria-checked": (
      /*checked*/
      ctx[3]
    ) },
    {
      "data-state": button_data_state_value = /*checked*/
      ctx[3] ? "checked" : "unchecked"
    },
    {
      "data-disabled": button_data_disabled_value = /*merged*/
      ctx[2].disabled ? "" : void 0
    },
    {
      disabled: button_disabled_value = /*merged*/
      ctx[2].disabled
    },
    { value: (
      /*value*/
      ctx[1]
    ) },
    /*$$restProps*/
    ctx[7]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      t = space();
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        role: true,
        "aria-checked": true,
        "data-state": true,
        "data-disabled": true
      });
      var button_nodes = children(button);
      if (default_slot)
        default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      input = claim_element(nodes, "INPUT", {
        type: true,
        "aria-hidden": true,
        tabindex: true,
        name: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      add_location(button, file41, 25, 0, 870);
      attr_dev(input, "type", "hidden");
      attr_dev(input, "aria-hidden", "");
      attr_dev(input, "tabindex", input_tabindex_value = -1);
      attr_dev(input, "name", input_name_value = /*$rootCtx*/
      ctx[4].name);
      input.value = /*value*/
      ctx[1];
      input.checked = /*checked*/
      ctx[3];
      input.required = input_required_value = /*merged*/
      ctx[2].required;
      input.disabled = input_disabled_value = /*merged*/
      ctx[2].disabled;
      add_location(input, file41, 53, 0, 1309);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, input, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useActions_action = useActions.call(null, button, [
            .../*use*/
            ctx[0] ?? [],
            [useCollection, { collection: (
              /*itemCollection*/
              ctx[6]
            ) }]
          ]))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        { role: "radio" },
        (!current || dirty & /*checked*/
        8) && { "aria-checked": (
          /*checked*/
          ctx2[3]
        ) },
        (!current || dirty & /*checked*/
        8 && button_data_state_value !== (button_data_state_value = /*checked*/
        ctx2[3] ? "checked" : "unchecked")) && { "data-state": button_data_state_value },
        (!current || dirty & /*merged*/
        4 && button_data_disabled_value !== (button_data_disabled_value = /*merged*/
        ctx2[2].disabled ? "" : void 0)) && {
          "data-disabled": button_data_disabled_value
        },
        (!current || dirty & /*merged*/
        4 && button_disabled_value !== (button_disabled_value = /*merged*/
        ctx2[2].disabled)) && { disabled: button_disabled_value },
        (!current || dirty & /*value*/
        2) && { value: (
          /*value*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(null, [
          .../*use*/
          ctx2[0] ?? [],
          [useCollection, { collection: (
            /*itemCollection*/
            ctx2[6]
          ) }]
        ]);
      if (!current || dirty & /*$rootCtx*/
      16 && input_name_value !== (input_name_value = /*$rootCtx*/
      ctx2[4].name)) {
        attr_dev(input, "name", input_name_value);
      }
      if (!current || dirty & /*value*/
      2) {
        prop_dev(
          input,
          "value",
          /*value*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*checked*/
      8) {
        prop_dev(
          input,
          "checked",
          /*checked*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*merged*/
      4 && input_required_value !== (input_required_value = /*merged*/
      ctx2[2].required)) {
        prop_dev(input, "required", input_required_value);
      }
      if (!current || dirty & /*merged*/
      4 && input_disabled_value !== (input_disabled_value = /*merged*/
      ctx2[2].disabled)) {
        prop_dev(input, "disabled", input_disabled_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
        detach_dev(t);
        detach_dev(input);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment50.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var defaults12 = { disabled: false };
var { getContext: getContext16, setContext: setContext16 } = reactiveContext(defaults12);
var getRadioGroupItemContext = getContext16;
function instance50($$self, $$props, $$invalidate) {
  let checked;
  let merged;
  const omit_props_names = ["use", "value", "disabled", "required"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Item", slots, ["default"]);
  let { use = [] } = $$props;
  let { value } = $$props;
  let { disabled = defaults12.disabled } = $$props;
  let { required = false } = $$props;
  const rootCtx = getRadioGroupRootContext();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value2) => $$invalidate(4, $rootCtx = value2));
  const itemCollection3 = getRadioGroupItemCollection();
  const ctx = setContext16();
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<Item> was created without expected prop 'value'");
    }
  });
  const click_handler = () => {
    if ($rootCtx.disabled) {
      return;
    }
    rootCtx.set({ value });
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("required" in $$new_props)
      $$invalidate(9, required = $$new_props.required);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useActions,
    useCollection,
    reactiveContext,
    getRadioGroupItemCollection,
    getRadioGroupRootContext,
    defaults: defaults12,
    getContext: getContext16,
    setContext: setContext16,
    getRadioGroupItemContext,
    use,
    value,
    disabled,
    required,
    rootCtx,
    itemCollection: itemCollection3,
    ctx,
    merged,
    checked,
    $rootCtx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
    if ("disabled" in $$props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("required" in $$props)
      $$invalidate(9, required = $$new_props.required);
    if ("merged" in $$props)
      $$invalidate(2, merged = $$new_props.merged);
    if ("checked" in $$props)
      $$invalidate(3, checked = $$new_props.checked);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$rootCtx, value*/
    18) {
      $:
        $$invalidate(3, checked = $rootCtx.value === value);
    }
    if ($$self.$$.dirty & /*disabled, $rootCtx, required*/
    784) {
      $:
        $$invalidate(2, merged = {
          disabled: disabled || $rootCtx.disabled,
          required: required || $rootCtx.required
        });
    }
    if ($$self.$$.dirty & /*checked, merged*/
    12) {
      $:
        ctx.set({ checked, disabled: merged.disabled });
    }
  };
  return [
    use,
    value,
    merged,
    checked,
    $rootCtx,
    rootCtx,
    itemCollection3,
    $$restProps,
    disabled,
    required,
    $$scope,
    slots,
    click_handler
  ];
}
var Item3 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance50, create_fragment50, safe_not_equal, {
      use: 0,
      value: 1,
      disabled: 8,
      required: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Item",
      options,
      id: create_fragment50.name
    });
  }
  get use() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var item_default3 = Item3;

// node_modules/radix-svelte/dist/components/RadioGroup/indicator.svelte
var file42 = "node_modules/radix-svelte/dist/components/RadioGroup/indicator.svelte";
function create_if_block10(ctx) {
  let span;
  let span_data_state_value;
  let span_data_disabled_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let span_levels = [
    {
      "data-state": span_data_state_value = /*$itemCtx*/
      ctx[1].checked ? "checked" : "unchecked"
    },
    {
      "data-disabled": span_data_disabled_value = /*$itemCtx*/
      ctx[1].disabled ? "" : void 0
    },
    /*$$restProps*/
    ctx[3]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        "data-state": true,
        "data-disabled": true
      });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file42, 9, 1, 255);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          span,
          /*use*/
          ctx[0] ?? []
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*$itemCtx*/
        2 && span_data_state_value !== (span_data_state_value = /*$itemCtx*/
        ctx2[1].checked ? "checked" : "unchecked")) && { "data-state": span_data_state_value },
        (!current || dirty & /*$itemCtx*/
        2 && span_data_disabled_value !== (span_data_disabled_value = /*$itemCtx*/
        ctx2[1].disabled ? "" : void 0)) && {
          "data-disabled": span_data_disabled_value
        },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0] ?? []
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(9:0) {#if $itemCtx.checked}",
    ctx
  });
  return block;
}
function create_fragment51(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$itemCtx*/
    ctx[1].checked && create_if_block10(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$itemCtx*/
        ctx2[1].checked
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$itemCtx*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block10(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment51.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance51($$self, $$props, $$invalidate) {
  const omit_props_names = ["use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $itemCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Indicator", slots, ["default"]);
  let { use = [] } = $$props;
  const itemCtx = getRadioGroupItemContext();
  validate_store(itemCtx, "itemCtx");
  component_subscribe($$self, itemCtx, (value) => $$invalidate(1, $itemCtx = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useActions,
    getRadioGroupItemContext,
    use,
    itemCtx,
    $itemCtx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [use, $itemCtx, itemCtx, $$restProps, $$scope, slots];
}
var Indicator3 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance51, create_fragment51, safe_not_equal, { use: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Indicator",
      options,
      id: create_fragment51.name
    });
  }
  get use() {
    throw new Error("<Indicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Indicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var indicator_default3 = Indicator3;

// node_modules/radix-svelte/dist/components/RadioGroup/index.js
var RadioGroup = {
  Root: root_default17,
  Item: item_default3,
  Indicator: indicator_default3
};

// node_modules/radix-svelte/dist/components/AlertDialog/root.svelte
function create_default_slot9(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: "(7:0) <Dialog.Root {...$$restProps} modal>",
    ctx
  });
  return block;
}
function create_fragment52(ctx) {
  let dialog_root;
  let current;
  const dialog_root_spread_levels = [
    /*$$restProps*/
    ctx[0],
    { modal: true }
  ];
  let dialog_root_props = {
    $$slots: { default: [create_default_slot9] },
    $$scope: { ctx }
  };
  for (let i = 0; i < dialog_root_spread_levels.length; i += 1) {
    dialog_root_props = assign(dialog_root_props, dialog_root_spread_levels[i]);
  }
  dialog_root = new Dialog.Root({ props: dialog_root_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(dialog_root.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(dialog_root.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(dialog_root, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const dialog_root_changes = dirty & /*$$restProps*/
      1 ? get_spread_update(dialog_root_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[0]
      ), dialog_root_spread_levels[1]]) : {};
      if (dirty & /*$$scope*/
      4) {
        dialog_root_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dialog_root.$set(dialog_root_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dialog_root.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dialog_root.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dialog_root, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment52.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance52($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, ["default"]);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ Dialog });
  return [$$restProps, slots, $$scope];
}
var Root18 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance52, create_fragment52, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment52.name
    });
  }
};
var root_default18 = Root18;

// node_modules/radix-svelte/dist/components/AlertDialog/trigger.svelte
function create_default_slot10(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: "(7:0) <Dialog.Trigger {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment53(ctx) {
  let dialog_trigger;
  let current;
  const dialog_trigger_spread_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let dialog_trigger_props = {
    $$slots: { default: [create_default_slot10] },
    $$scope: { ctx }
  };
  for (let i = 0; i < dialog_trigger_spread_levels.length; i += 1) {
    dialog_trigger_props = assign(dialog_trigger_props, dialog_trigger_spread_levels[i]);
  }
  dialog_trigger = new Dialog.Trigger({
    props: dialog_trigger_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(dialog_trigger.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(dialog_trigger.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(dialog_trigger, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const dialog_trigger_changes = dirty & /*$$restProps*/
      1 ? get_spread_update(dialog_trigger_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      4) {
        dialog_trigger_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dialog_trigger.$set(dialog_trigger_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dialog_trigger.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dialog_trigger.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dialog_trigger, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment53.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance53($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Trigger", slots, ["default"]);
  "use strict";
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ Dialog });
  return [$$restProps, slots, $$scope];
}
var Trigger5 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance53, create_fragment53, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Trigger",
      options,
      id: create_fragment53.name
    });
  }
};
var trigger_default5 = Trigger5;

// node_modules/radix-svelte/dist/components/AlertDialog/portal.svelte
function create_default_slot11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: "(7:0) <Dialog.Portal {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment54(ctx) {
  let dialog_portal;
  let current;
  const dialog_portal_spread_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let dialog_portal_props = {
    $$slots: { default: [create_default_slot11] },
    $$scope: { ctx }
  };
  for (let i = 0; i < dialog_portal_spread_levels.length; i += 1) {
    dialog_portal_props = assign(dialog_portal_props, dialog_portal_spread_levels[i]);
  }
  dialog_portal = new Dialog.Portal({
    props: dialog_portal_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(dialog_portal.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(dialog_portal.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(dialog_portal, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const dialog_portal_changes = dirty & /*$$restProps*/
      1 ? get_spread_update(dialog_portal_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      4) {
        dialog_portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dialog_portal.$set(dialog_portal_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dialog_portal.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dialog_portal.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dialog_portal, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment54.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance54($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Portal", slots, ["default"]);
  "use strict";
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ Dialog });
  return [$$restProps, slots, $$scope];
}
var Portal2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance54, create_fragment54, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Portal",
      options,
      id: create_fragment54.name
    });
  }
};
var portal_default2 = Portal2;

// node_modules/radix-svelte/dist/components/AlertDialog/overlay.svelte
function create_default_slot12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: "(7:0) <Dialog.Overlay {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment55(ctx) {
  let dialog_overlay;
  let current;
  const dialog_overlay_spread_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let dialog_overlay_props = {
    $$slots: { default: [create_default_slot12] },
    $$scope: { ctx }
  };
  for (let i = 0; i < dialog_overlay_spread_levels.length; i += 1) {
    dialog_overlay_props = assign(dialog_overlay_props, dialog_overlay_spread_levels[i]);
  }
  dialog_overlay = new Dialog.Overlay({
    props: dialog_overlay_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(dialog_overlay.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(dialog_overlay.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(dialog_overlay, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const dialog_overlay_changes = dirty & /*$$restProps*/
      1 ? get_spread_update(dialog_overlay_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      4) {
        dialog_overlay_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dialog_overlay.$set(dialog_overlay_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dialog_overlay.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dialog_overlay.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dialog_overlay, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment55.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance55($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Overlay", slots, ["default"]);
  "use strict";
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ Dialog });
  return [$$restProps, slots, $$scope];
}
var Overlay2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance55, create_fragment55, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Overlay",
      options,
      id: create_fragment55.name
    });
  }
};
var overlay_default2 = Overlay2;

// node_modules/radix-svelte/dist/components/AlertDialog/content.svelte
function create_default_slot13(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot13.name,
    type: "slot",
    source: '(12:0) <Dialog.Content  role=\\"alertdialog\\"  on:pointerDownOutside={(e) => {   e.detail.preventDefault();  }}  openAutoFocus={resolvedOpenAutoFocus}  {...$$restProps} >',
    ctx
  });
  return block;
}
function create_fragment56(ctx) {
  let dialog_content;
  let current;
  const dialog_content_spread_levels = [
    { role: "alertdialog" },
    {
      openAutoFocus: (
        /*resolvedOpenAutoFocus*/
        ctx[0]
      )
    },
    /*$$restProps*/
    ctx[2]
  ];
  let dialog_content_props = {
    $$slots: { default: [create_default_slot13] },
    $$scope: { ctx }
  };
  for (let i = 0; i < dialog_content_spread_levels.length; i += 1) {
    dialog_content_props = assign(dialog_content_props, dialog_content_spread_levels[i]);
  }
  dialog_content = new Dialog.Content({
    props: dialog_content_props,
    $$inline: true
  });
  dialog_content.$on("pointerDownOutside", pointerDownOutside_handler);
  const block = {
    c: function create() {
      create_component(dialog_content.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(dialog_content.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(dialog_content, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const dialog_content_changes = dirty & /*resolvedOpenAutoFocus, $$restProps*/
      5 ? get_spread_update(dialog_content_spread_levels, [
        dialog_content_spread_levels[0],
        dirty & /*resolvedOpenAutoFocus*/
        1 && {
          openAutoFocus: (
            /*resolvedOpenAutoFocus*/
            ctx2[0]
          )
        },
        dirty & /*$$restProps*/
        4 && get_spread_object(
          /*$$restProps*/
          ctx2[2]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      64) {
        dialog_content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dialog_content.$set(dialog_content_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dialog_content.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dialog_content.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dialog_content, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment56.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cancelCollectionCtx = collectionContext();
var getCancelCollection = cancelCollectionCtx.getContext;
var pointerDownOutside_handler = (e) => {
  e.detail.preventDefault();
};
function instance56($$self, $$props, $$invalidate) {
  let resolvedOpenAutoFocus;
  const omit_props_names = ["openAutoFocus"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $cancelCollection;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Content", slots, ["default"]);
  const cancelCollection = cancelCollectionCtx.setContext();
  validate_store(cancelCollection, "cancelCollection");
  component_subscribe($$self, cancelCollection, (value) => $$invalidate(4, $cancelCollection = value));
  let { openAutoFocus = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("openAutoFocus" in $$new_props)
      $$invalidate(3, openAutoFocus = $$new_props.openAutoFocus);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    collectionContext,
    Dialog,
    cancelCollectionCtx,
    getCancelCollection,
    cancelCollection,
    openAutoFocus,
    resolvedOpenAutoFocus,
    $cancelCollection
  });
  $$self.$inject_state = ($$new_props) => {
    if ("openAutoFocus" in $$props)
      $$invalidate(3, openAutoFocus = $$new_props.openAutoFocus);
    if ("resolvedOpenAutoFocus" in $$props)
      $$invalidate(0, resolvedOpenAutoFocus = $$new_props.resolvedOpenAutoFocus);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*openAutoFocus, $cancelCollection*/
    24) {
      $:
        $$invalidate(0, resolvedOpenAutoFocus = openAutoFocus === void 0 ? $cancelCollection[0] : true);
    }
  };
  return [
    resolvedOpenAutoFocus,
    cancelCollection,
    $$restProps,
    openAutoFocus,
    $cancelCollection,
    slots,
    $$scope
  ];
}
var Content6 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance56, create_fragment56, safe_not_equal, { openAutoFocus: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Content",
      options,
      id: create_fragment56.name
    });
  }
  get openAutoFocus() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set openAutoFocus(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var content_default6 = Content6;

// node_modules/radix-svelte/dist/components/AlertDialog/cancel.svelte
function create_default_slot14(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot14.name,
    type: "slot",
    source: "(10:0) <Dialog.Close  {...$$restProps}  use={[   ...($$restProps.use ?? []),   [    useCollection,    {     collection: cancelCollection,    },   ],  ]} >",
    ctx
  });
  return block;
}
function create_fragment57(ctx) {
  let dialog_close;
  let current;
  const dialog_close_spread_levels = [
    /*$$restProps*/
    ctx[1],
    {
      use: [
        .../*$$restProps*/
        ctx[1].use ?? [],
        [useCollection, { collection: (
          /*cancelCollection*/
          ctx[0]
        ) }]
      ]
    }
  ];
  let dialog_close_props = {
    $$slots: { default: [create_default_slot14] },
    $$scope: { ctx }
  };
  for (let i = 0; i < dialog_close_spread_levels.length; i += 1) {
    dialog_close_props = assign(dialog_close_props, dialog_close_spread_levels[i]);
  }
  dialog_close = new Dialog.Close({
    props: dialog_close_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(dialog_close.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(dialog_close.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(dialog_close, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const dialog_close_changes = dirty & /*$$restProps, useCollection, cancelCollection*/
      3 ? get_spread_update(dialog_close_spread_levels, [
        dirty & /*$$restProps*/
        2 && get_spread_object(
          /*$$restProps*/
          ctx2[1]
        ),
        {
          use: [
            .../*$$restProps*/
            ctx2[1].use ?? [],
            [useCollection, { collection: (
              /*cancelCollection*/
              ctx2[0]
            ) }]
          ]
        }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        dialog_close_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dialog_close.$set(dialog_close_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dialog_close.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dialog_close.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dialog_close, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment57.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance57($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Cancel", slots, ["default"]);
  "use strict";
  const cancelCollection = getCancelCollection();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useCollection,
    Dialog,
    getCancelCollection,
    cancelCollection
  });
  return [cancelCollection, $$restProps, slots, $$scope];
}
var Cancel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance57, create_fragment57, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Cancel",
      options,
      id: create_fragment57.name
    });
  }
};
var cancel_default = Cancel;

// node_modules/radix-svelte/dist/components/AlertDialog/action.svelte
function create_default_slot15(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot15.name,
    type: "slot",
    source: "(7:0) <Dialog.Close {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment58(ctx) {
  let dialog_close;
  let current;
  const dialog_close_spread_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let dialog_close_props = {
    $$slots: { default: [create_default_slot15] },
    $$scope: { ctx }
  };
  for (let i = 0; i < dialog_close_spread_levels.length; i += 1) {
    dialog_close_props = assign(dialog_close_props, dialog_close_spread_levels[i]);
  }
  dialog_close = new Dialog.Close({
    props: dialog_close_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(dialog_close.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(dialog_close.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(dialog_close, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const dialog_close_changes = dirty & /*$$restProps*/
      1 ? get_spread_update(dialog_close_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      4) {
        dialog_close_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dialog_close.$set(dialog_close_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dialog_close.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dialog_close.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dialog_close, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment58.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance58($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Action", slots, ["default"]);
  "use strict";
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ Dialog });
  return [$$restProps, slots, $$scope];
}
var Action = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance58, create_fragment58, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Action",
      options,
      id: create_fragment58.name
    });
  }
};
var action_default = Action;

// node_modules/radix-svelte/dist/components/AlertDialog/title.svelte
function create_default_slot16(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot16.name,
    type: "slot",
    source: "(7:0) <Dialog.Title {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment59(ctx) {
  let dialog_title;
  let current;
  const dialog_title_spread_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let dialog_title_props = {
    $$slots: { default: [create_default_slot16] },
    $$scope: { ctx }
  };
  for (let i = 0; i < dialog_title_spread_levels.length; i += 1) {
    dialog_title_props = assign(dialog_title_props, dialog_title_spread_levels[i]);
  }
  dialog_title = new Dialog.Title({
    props: dialog_title_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(dialog_title.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(dialog_title.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(dialog_title, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const dialog_title_changes = dirty & /*$$restProps*/
      1 ? get_spread_update(dialog_title_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      4) {
        dialog_title_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dialog_title.$set(dialog_title_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dialog_title.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dialog_title.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dialog_title, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment59.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance59($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Title", slots, ["default"]);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ Dialog });
  return [$$restProps, slots, $$scope];
}
var Title2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance59, create_fragment59, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Title",
      options,
      id: create_fragment59.name
    });
  }
};
var title_default2 = Title2;

// node_modules/radix-svelte/dist/components/AlertDialog/description.svelte
function create_default_slot17(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot17.name,
    type: "slot",
    source: "(7:0) <Dialog.Description {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment60(ctx) {
  let dialog_description;
  let current;
  const dialog_description_spread_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let dialog_description_props = {
    $$slots: { default: [create_default_slot17] },
    $$scope: { ctx }
  };
  for (let i = 0; i < dialog_description_spread_levels.length; i += 1) {
    dialog_description_props = assign(dialog_description_props, dialog_description_spread_levels[i]);
  }
  dialog_description = new Dialog.Description({
    props: dialog_description_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(dialog_description.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(dialog_description.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(dialog_description, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const dialog_description_changes = dirty & /*$$restProps*/
      1 ? get_spread_update(dialog_description_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      4) {
        dialog_description_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dialog_description.$set(dialog_description_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dialog_description.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dialog_description.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dialog_description, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment60.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance60($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Description", slots, ["default"]);
  "use strict";
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ Dialog });
  return [$$restProps, slots, $$scope];
}
var Description2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance60, create_fragment60, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Description",
      options,
      id: create_fragment60.name
    });
  }
};
var description_default2 = Description2;

// node_modules/radix-svelte/dist/components/AlertDialog/index.js
var AlertDialog = {
  Root: root_default18,
  Trigger: trigger_default5,
  Portal: portal_default2,
  Overlay: overlay_default2,
  Content: content_default6,
  Cancel: cancel_default,
  Action: action_default,
  Title: title_default2,
  Description: description_default2
};

// node_modules/radix-svelte/dist/components/HoverCard/root.svelte
function create_default_slot18(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot18.name,
    type: "slot",
    source: "(27:0) <Popper.Root {use} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment61(ctx) {
  let popper_root;
  let current;
  const popper_root_spread_levels = [
    { use: (
      /*use*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[1]
  ];
  let popper_root_props = {
    $$slots: { default: [create_default_slot18] },
    $$scope: { ctx }
  };
  for (let i = 0; i < popper_root_spread_levels.length; i += 1) {
    popper_root_props = assign(popper_root_props, popper_root_spread_levels[i]);
  }
  popper_root = new Popper.Root({ props: popper_root_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(popper_root.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(popper_root.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(popper_root, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const popper_root_changes = dirty & /*use, $$restProps*/
      3 ? get_spread_update(popper_root_spread_levels, [
        dirty & /*use*/
        1 && { use: (
          /*use*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && get_spread_object(
          /*$$restProps*/
          ctx2[1]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      64) {
        popper_root_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popper_root.$set(popper_root_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(popper_root.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(popper_root.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(popper_root, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment61.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var defaults13 = {
  open: false,
  openDelay: 750,
  closeDelay: 300
};
var { getContext: getContext17, setContext: setContext17 } = reactiveContext(defaults13);
var getRootContext6 = getContext17;
function instance61($$self, $$props, $$invalidate) {
  const omit_props_names = ["open", "openDelay", "closeDelay", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, ["default"]);
  let { open = defaults13.open } = $$props;
  let { openDelay = defaults13.openDelay } = $$props;
  let { closeDelay = defaults13.closeDelay } = $$props;
  let { use = [] } = $$props;
  const ctx = setContext17({ open: (v) => $$invalidate(2, open = v) });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("open" in $$new_props)
      $$invalidate(2, open = $$new_props.open);
    if ("openDelay" in $$new_props)
      $$invalidate(3, openDelay = $$new_props.openDelay);
    if ("closeDelay" in $$new_props)
      $$invalidate(4, closeDelay = $$new_props.closeDelay);
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    defaults: defaults13,
    getContext: getContext17,
    setContext: setContext17,
    getRootContext: getRootContext6,
    Popper,
    reactiveContext,
    open,
    openDelay,
    closeDelay,
    use,
    ctx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("open" in $$props)
      $$invalidate(2, open = $$new_props.open);
    if ("openDelay" in $$props)
      $$invalidate(3, openDelay = $$new_props.openDelay);
    if ("closeDelay" in $$props)
      $$invalidate(4, closeDelay = $$new_props.closeDelay);
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open, openDelay, closeDelay*/
    28) {
      $:
        ctx.update((prev2) => ({ ...prev2, open, openDelay, closeDelay }));
    }
  };
  return [use, $$restProps, open, openDelay, closeDelay, slots, $$scope];
}
var Root19 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance61, create_fragment61, safe_not_equal, {
      open: 2,
      openDelay: 3,
      closeDelay: 4,
      use: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment61.name
    });
  }
  get open() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get openDelay() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set openDelay(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeDelay() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeDelay(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var root_default19 = Root19;

// node_modules/radix-svelte/dist/components/HoverCard/portal.svelte
function create_if_block11(ctx) {
  let portal2;
  let current;
  const portal_spread_levels = [
    { target: (
      /*container*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let portal_props = {
    $$slots: { default: [create_default_slot19] },
    $$scope: { ctx }
  };
  for (let i = 0; i < portal_spread_levels.length; i += 1) {
    portal_props = assign(portal_props, portal_spread_levels[i]);
  }
  portal2 = new Portal_default({ props: portal_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(portal2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(portal2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(portal2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const portal_changes = dirty & /*container, $$restProps*/
      9 ? get_spread_update(portal_spread_levels, [
        dirty & /*container*/
        1 && { target: (
          /*container*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      32) {
        portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portal2.$set(portal_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(portal2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(portal2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(portal2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(10:0) {#if $ctx.open}",
    ctx
  });
  return block;
}
function create_default_slot19(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot19.name,
    type: "slot",
    source: "(11:1) <Portal target={container} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment62(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$ctx*/
    ctx[1].open && create_if_block11(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$ctx*/
        ctx2[1].open
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$ctx*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block11(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment62.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance62($$self, $$props, $$invalidate) {
  const omit_props_names = ["container"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $ctx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Portal", slots, ["default"]);
  let { container = "body" } = $$props;
  const ctx = getRootContext6();
  validate_store(ctx, "ctx");
  component_subscribe($$self, ctx, (value) => $$invalidate(1, $ctx = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("container" in $$new_props)
      $$invalidate(0, container = $$new_props.container);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Portal: Portal_default,
    getRootContext: getRootContext6,
    container,
    ctx,
    $ctx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("container" in $$props)
      $$invalidate(0, container = $$new_props.container);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [container, $ctx, ctx, $$restProps, slots, $$scope];
}
var Portal_12 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance62, create_fragment62, safe_not_equal, { container: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Portal_1",
      options,
      id: create_fragment62.name
    });
  }
  get container() {
    throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var portal_default3 = Portal_12;

// node_modules/radix-svelte/dist/components/HoverCard/trigger.svelte
function create_default_slot20(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot20.name,
    type: "slot",
    source: `(22:0) <Popper.Anchor  as=\\"a\\"  on:pointerenter={open}  on:pointerleave={close}  on:focus={open}  on:blur={close}  on:touchstart={(e) => e.preventDefault()}  use={[...(use ?? [])]}  data-state={$ctx.open ? 'open' : 'closed'}  {...$$restProps} >`,
    ctx
  });
  return block;
}
function create_fragment63(ctx) {
  let popper_anchor;
  let current;
  const popper_anchor_spread_levels = [
    { as: "a" },
    { use: [.../*use*/
    ctx[0] ?? []] },
    {
      "data-state": (
        /*$ctx*/
        ctx[1].open ? "open" : "closed"
      )
    },
    /*$$restProps*/
    ctx[5]
  ];
  let popper_anchor_props = {
    $$slots: { default: [create_default_slot20] },
    $$scope: { ctx }
  };
  for (let i = 0; i < popper_anchor_spread_levels.length; i += 1) {
    popper_anchor_props = assign(popper_anchor_props, popper_anchor_spread_levels[i]);
  }
  popper_anchor = new Popper.Anchor({
    props: popper_anchor_props,
    $$inline: true
  });
  popper_anchor.$on(
    "pointerenter",
    /*open*/
    ctx[3]
  );
  popper_anchor.$on(
    "pointerleave",
    /*close*/
    ctx[4]
  );
  popper_anchor.$on(
    "focus",
    /*open*/
    ctx[3]
  );
  popper_anchor.$on(
    "blur",
    /*close*/
    ctx[4]
  );
  popper_anchor.$on("touchstart", touchstart_handler);
  const block = {
    c: function create() {
      create_component(popper_anchor.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(popper_anchor.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(popper_anchor, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const popper_anchor_changes = dirty & /*use, $ctx, $$restProps*/
      35 ? get_spread_update(popper_anchor_spread_levels, [
        popper_anchor_spread_levels[0],
        dirty & /*use*/
        1 && { use: [.../*use*/
        ctx2[0] ?? []] },
        dirty & /*$ctx*/
        2 && {
          "data-state": (
            /*$ctx*/
            ctx2[1].open ? "open" : "closed"
          )
        },
        dirty & /*$$restProps*/
        32 && get_spread_object(
          /*$$restProps*/
          ctx2[5]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      128) {
        popper_anchor_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popper_anchor.$set(popper_anchor_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(popper_anchor.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(popper_anchor.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(popper_anchor, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment63.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var touchstart_handler = (e) => e.preventDefault();
function instance63($$self, $$props, $$invalidate) {
  const omit_props_names = ["use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $ctx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Trigger", slots, ["default"]);
  let { use = [] } = $$props;
  const ctx = getRootContext6();
  validate_store(ctx, "ctx");
  component_subscribe($$self, ctx, (value) => $$invalidate(1, $ctx = value));
  const dispatch = createEventDispatcher();
  const open = () => {
    clearTimeout($ctx.closeTimer);
    const timer = setTimeout(() => set_store_value(ctx, $ctx.open = true, $ctx), $ctx.openDelay);
    set_store_value(ctx, $ctx.openTimer = timer, $ctx);
  };
  const close = () => {
    clearTimeout($ctx.openTimer);
    set_store_value(ctx, $ctx.closeTimer = setTimeout(() => set_store_value(ctx, $ctx.open = false, $ctx), $ctx.closeDelay), $ctx);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Popper,
    getRootContext: getRootContext6,
    createEventDispatcher,
    use,
    ctx,
    dispatch,
    open,
    close,
    $ctx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$ctx*/
    2) {
      $:
        dispatch("change", $ctx.open);
    }
  };
  return [use, $ctx, ctx, open, close, $$restProps, slots, $$scope];
}
var Trigger6 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance63, create_fragment63, safe_not_equal, { use: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Trigger",
      options,
      id: create_fragment63.name
    });
  }
  get use() {
    throw new Error("<Trigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Trigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var trigger_default6 = Trigger6;

// node_modules/radix-svelte/dist/components/HoverCard/content.svelte
function create_default_slot21(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot21.name,
    type: "slot",
    source: "(26:0) <Popper.Content  on:pointerenter={active}  on:pointerleave={inactive}  on:focus={active}  on:blur={inactive}  {side}  {sideOffset}  {align}  {alignOffset}  {arrowPadding}  {collisionBoundary}  {collisionPadding}  {sticky}  {hideWhenDetached}  {avoidCollisions}  data-state={$ctx.open ? 'open' : 'closed'}  {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment64(ctx) {
  let popper_content;
  let current;
  const popper_content_spread_levels = [
    { side: (
      /*side*/
      ctx[0]
    ) },
    { sideOffset: (
      /*sideOffset*/
      ctx[1]
    ) },
    { align: (
      /*align*/
      ctx[2]
    ) },
    { alignOffset: (
      /*alignOffset*/
      ctx[3]
    ) },
    { arrowPadding: (
      /*arrowPadding*/
      ctx[4]
    ) },
    {
      collisionBoundary: (
        /*collisionBoundary*/
        ctx[5]
      )
    },
    {
      collisionPadding: (
        /*collisionPadding*/
        ctx[6]
      )
    },
    { sticky: (
      /*sticky*/
      ctx[7]
    ) },
    {
      hideWhenDetached: (
        /*hideWhenDetached*/
        ctx[8]
      )
    },
    {
      avoidCollisions: (
        /*avoidCollisions*/
        ctx[9]
      )
    },
    {
      "data-state": (
        /*$ctx*/
        ctx[10].open ? "open" : "closed"
      )
    },
    /*$$restProps*/
    ctx[14]
  ];
  let popper_content_props = {
    $$slots: { default: [create_default_slot21] },
    $$scope: { ctx }
  };
  for (let i = 0; i < popper_content_spread_levels.length; i += 1) {
    popper_content_props = assign(popper_content_props, popper_content_spread_levels[i]);
  }
  popper_content = new Popper.Content({
    props: popper_content_props,
    $$inline: true
  });
  popper_content.$on(
    "pointerenter",
    /*active*/
    ctx[12]
  );
  popper_content.$on(
    "pointerleave",
    /*inactive*/
    ctx[13]
  );
  popper_content.$on(
    "focus",
    /*active*/
    ctx[12]
  );
  popper_content.$on(
    "blur",
    /*inactive*/
    ctx[13]
  );
  const block = {
    c: function create() {
      create_component(popper_content.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(popper_content.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(popper_content, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const popper_content_changes = dirty & /*side, sideOffset, align, alignOffset, arrowPadding, collisionBoundary, collisionPadding, sticky, hideWhenDetached, avoidCollisions, $ctx, $$restProps*/
      18431 ? get_spread_update(popper_content_spread_levels, [
        dirty & /*side*/
        1 && { side: (
          /*side*/
          ctx2[0]
        ) },
        dirty & /*sideOffset*/
        2 && { sideOffset: (
          /*sideOffset*/
          ctx2[1]
        ) },
        dirty & /*align*/
        4 && { align: (
          /*align*/
          ctx2[2]
        ) },
        dirty & /*alignOffset*/
        8 && { alignOffset: (
          /*alignOffset*/
          ctx2[3]
        ) },
        dirty & /*arrowPadding*/
        16 && { arrowPadding: (
          /*arrowPadding*/
          ctx2[4]
        ) },
        dirty & /*collisionBoundary*/
        32 && {
          collisionBoundary: (
            /*collisionBoundary*/
            ctx2[5]
          )
        },
        dirty & /*collisionPadding*/
        64 && {
          collisionPadding: (
            /*collisionPadding*/
            ctx2[6]
          )
        },
        dirty & /*sticky*/
        128 && { sticky: (
          /*sticky*/
          ctx2[7]
        ) },
        dirty & /*hideWhenDetached*/
        256 && {
          hideWhenDetached: (
            /*hideWhenDetached*/
            ctx2[8]
          )
        },
        dirty & /*avoidCollisions*/
        512 && {
          avoidCollisions: (
            /*avoidCollisions*/
            ctx2[9]
          )
        },
        dirty & /*$ctx*/
        1024 && {
          "data-state": (
            /*$ctx*/
            ctx2[10].open ? "open" : "closed"
          )
        },
        dirty & /*$$restProps*/
        16384 && get_spread_object(
          /*$$restProps*/
          ctx2[14]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      65536) {
        popper_content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popper_content.$set(popper_content_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(popper_content.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(popper_content.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(popper_content, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment64.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance64($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "side",
    "sideOffset",
    "align",
    "alignOffset",
    "arrowPadding",
    "collisionBoundary",
    "collisionPadding",
    "sticky",
    "hideWhenDetached",
    "avoidCollisions"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $ctx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Content", slots, ["default"]);
  const ctx = getRootContext6();
  validate_store(ctx, "ctx");
  component_subscribe($$self, ctx, (value) => $$invalidate(10, $ctx = value));
  let { side = "bottom" } = $$props;
  let { sideOffset = 0 } = $$props;
  let { align = "center" } = $$props;
  let { alignOffset = 0 } = $$props;
  let { arrowPadding = 0 } = $$props;
  let { collisionBoundary = [] } = $$props;
  let { collisionPadding = 0 } = $$props;
  let { sticky = "partial" } = $$props;
  let { hideWhenDetached = false } = $$props;
  let { avoidCollisions = true } = $$props;
  function active() {
    clearTimeout($ctx.closeTimer);
    set_store_value(ctx, $ctx.closeTimer = void 0, $ctx);
  }
  function inactive() {
    set_store_value(ctx, $ctx.closeTimer = setTimeout(() => set_store_value(ctx, $ctx.open = false, $ctx), $ctx.closeDelay), $ctx);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("side" in $$new_props)
      $$invalidate(0, side = $$new_props.side);
    if ("sideOffset" in $$new_props)
      $$invalidate(1, sideOffset = $$new_props.sideOffset);
    if ("align" in $$new_props)
      $$invalidate(2, align = $$new_props.align);
    if ("alignOffset" in $$new_props)
      $$invalidate(3, alignOffset = $$new_props.alignOffset);
    if ("arrowPadding" in $$new_props)
      $$invalidate(4, arrowPadding = $$new_props.arrowPadding);
    if ("collisionBoundary" in $$new_props)
      $$invalidate(5, collisionBoundary = $$new_props.collisionBoundary);
    if ("collisionPadding" in $$new_props)
      $$invalidate(6, collisionPadding = $$new_props.collisionPadding);
    if ("sticky" in $$new_props)
      $$invalidate(7, sticky = $$new_props.sticky);
    if ("hideWhenDetached" in $$new_props)
      $$invalidate(8, hideWhenDetached = $$new_props.hideWhenDetached);
    if ("avoidCollisions" in $$new_props)
      $$invalidate(9, avoidCollisions = $$new_props.avoidCollisions);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Popper,
    getRootContext: getRootContext6,
    ctx,
    side,
    sideOffset,
    align,
    alignOffset,
    arrowPadding,
    collisionBoundary,
    collisionPadding,
    sticky,
    hideWhenDetached,
    avoidCollisions,
    active,
    inactive,
    $ctx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("side" in $$props)
      $$invalidate(0, side = $$new_props.side);
    if ("sideOffset" in $$props)
      $$invalidate(1, sideOffset = $$new_props.sideOffset);
    if ("align" in $$props)
      $$invalidate(2, align = $$new_props.align);
    if ("alignOffset" in $$props)
      $$invalidate(3, alignOffset = $$new_props.alignOffset);
    if ("arrowPadding" in $$props)
      $$invalidate(4, arrowPadding = $$new_props.arrowPadding);
    if ("collisionBoundary" in $$props)
      $$invalidate(5, collisionBoundary = $$new_props.collisionBoundary);
    if ("collisionPadding" in $$props)
      $$invalidate(6, collisionPadding = $$new_props.collisionPadding);
    if ("sticky" in $$props)
      $$invalidate(7, sticky = $$new_props.sticky);
    if ("hideWhenDetached" in $$props)
      $$invalidate(8, hideWhenDetached = $$new_props.hideWhenDetached);
    if ("avoidCollisions" in $$props)
      $$invalidate(9, avoidCollisions = $$new_props.avoidCollisions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    side,
    sideOffset,
    align,
    alignOffset,
    arrowPadding,
    collisionBoundary,
    collisionPadding,
    sticky,
    hideWhenDetached,
    avoidCollisions,
    $ctx,
    ctx,
    active,
    inactive,
    $$restProps,
    slots,
    $$scope
  ];
}
var Content7 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance64, create_fragment64, safe_not_equal, {
      side: 0,
      sideOffset: 1,
      align: 2,
      alignOffset: 3,
      arrowPadding: 4,
      collisionBoundary: 5,
      collisionPadding: 6,
      sticky: 7,
      hideWhenDetached: 8,
      avoidCollisions: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Content",
      options,
      id: create_fragment64.name
    });
  }
  get side() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set side(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sideOffset() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sideOffset(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alignOffset() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alignOffset(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrowPadding() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrowPadding(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get collisionBoundary() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set collisionBoundary(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get collisionPadding() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set collisionPadding(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sticky() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sticky(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideWhenDetached() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideWhenDetached(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get avoidCollisions() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set avoidCollisions(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var content_default7 = Content7;

// node_modules/radix-svelte/dist/components/HoverCard/index.js
var HoverCard = {
  Root: root_default19,
  Portal: portal_default3,
  Trigger: trigger_default6,
  Content: content_default7,
  Arrow: arrow_default
};

// node_modules/radix-svelte/dist/components/Tooltip/provider.svelte
function create_fragment65(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment65.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var defaults14 = {
  isOpenDelayed: true,
  isPointerInTransit: false,
  disableHoverableContent: false
};
var { getContext: getContext18, setContext: setContext18 } = reactiveContext(defaults14);
var getTooltipProviderContext = getContext18;
function instance65($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Provider", slots, ["default"]);
  let { delayDuration = 300 } = $$props;
  let { skipDelayDuration = 300 } = $$props;
  let { disableHoverableContent = defaults14.disableHoverableContent } = $$props;
  let skipDelayTimer = 0;
  let isOpenDelayed = defaults14.isOpenDelayed;
  const handleOpen = () => {
    if (!isBrowser)
      return;
    window.clearTimeout(skipDelayTimer);
    $$invalidate(3, isOpenDelayed = false);
  };
  const handleClose = () => {
    if (!isBrowser)
      return;
    window.clearTimeout(skipDelayTimer);
    skipDelayTimer = window.setTimeout(
      () => {
        $$invalidate(3, isOpenDelayed = true);
      },
      skipDelayDuration
    );
  };
  const ctx = setContext18();
  const writable_props = ["delayDuration", "skipDelayDuration", "disableHoverableContent"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Provider> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("delayDuration" in $$props2)
      $$invalidate(0, delayDuration = $$props2.delayDuration);
    if ("skipDelayDuration" in $$props2)
      $$invalidate(1, skipDelayDuration = $$props2.skipDelayDuration);
    if ("disableHoverableContent" in $$props2)
      $$invalidate(2, disableHoverableContent = $$props2.disableHoverableContent);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    reactiveContext,
    isBrowser,
    defaults: defaults14,
    getContext: getContext18,
    setContext: setContext18,
    getTooltipProviderContext,
    delayDuration,
    skipDelayDuration,
    disableHoverableContent,
    skipDelayTimer,
    isOpenDelayed,
    handleOpen,
    handleClose,
    ctx
  });
  $$self.$inject_state = ($$props2) => {
    if ("delayDuration" in $$props2)
      $$invalidate(0, delayDuration = $$props2.delayDuration);
    if ("skipDelayDuration" in $$props2)
      $$invalidate(1, skipDelayDuration = $$props2.skipDelayDuration);
    if ("disableHoverableContent" in $$props2)
      $$invalidate(2, disableHoverableContent = $$props2.disableHoverableContent);
    if ("skipDelayTimer" in $$props2)
      skipDelayTimer = $$props2.skipDelayTimer;
    if ("isOpenDelayed" in $$props2)
      $$invalidate(3, isOpenDelayed = $$props2.isOpenDelayed);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*delayDuration, isOpenDelayed, disableHoverableContent*/
    13) {
      $:
        ctx.update((prev2) => ({
          ...prev2,
          delayDuration,
          isOpenDelayed,
          onOpen: handleOpen,
          onClose: handleClose,
          disableHoverableContent
        }));
    }
  };
  return [
    delayDuration,
    skipDelayDuration,
    disableHoverableContent,
    isOpenDelayed,
    $$scope,
    slots
  ];
}
var Provider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance65, create_fragment65, safe_not_equal, {
      delayDuration: 0,
      skipDelayDuration: 1,
      disableHoverableContent: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Provider",
      options,
      id: create_fragment65.name
    });
  }
  get delayDuration() {
    throw new Error("<Provider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set delayDuration(value) {
    throw new Error("<Provider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skipDelayDuration() {
    throw new Error("<Provider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skipDelayDuration(value) {
    throw new Error("<Provider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableHoverableContent() {
    throw new Error("<Provider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableHoverableContent(value) {
    throw new Error("<Provider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var provider_default = Provider;

// node_modules/radix-svelte/dist/components/Tooltip/constants.js
var TOOLTIP_OPEN = "tooltip.open";

// node_modules/radix-svelte/dist/components/Tooltip/root.svelte
function create_default_slot22(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot22.name,
    type: "slot",
    source: "(98:0) <Popper.Root {use} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment66(ctx) {
  let popper_root;
  let current;
  const popper_root_spread_levels = [
    { use: (
      /*use*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let popper_root_props = {
    $$slots: { default: [create_default_slot22] },
    $$scope: { ctx }
  };
  for (let i = 0; i < popper_root_spread_levels.length; i += 1) {
    popper_root_props = assign(popper_root_props, popper_root_spread_levels[i]);
  }
  popper_root = new Popper.Root({ props: popper_root_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(popper_root.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(popper_root.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(popper_root, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const popper_root_changes = dirty & /*use, $$restProps*/
      9 ? get_spread_update(popper_root_spread_levels, [
        dirty & /*use*/
        1 && { use: (
          /*use*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      4096) {
        popper_root_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popper_root.$set(popper_root_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(popper_root.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(popper_root.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(popper_root, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment66.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var defaults15 = {
  open: false,
  contentId: generateId(),
  trigger: null
};
var { getContext: getContext19, setContext: setContext19 } = reactiveContext(defaults15);
var getTooltipRootContext = getContext19;
function instance66($$self, $$props, $$invalidate) {
  let stateAttribute;
  const omit_props_names = ["open", "delayDuration", "disableHoverableContent", "use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $providerCtx;
  let $ctx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Root", slots, ["default"]);
  let { open = defaults15.open } = $$props;
  let { delayDuration = void 0 } = $$props;
  let { disableHoverableContent = void 0 } = $$props;
  let { use = [] } = $$props;
  const providerCtx = getTooltipProviderContext();
  validate_store(providerCtx, "providerCtx");
  component_subscribe($$self, providerCtx, (value) => $$invalidate(9, $providerCtx = value));
  const ctx = setContext19({
    open: (v) => {
      if (v) {
        $providerCtx == null ? void 0 : $providerCtx.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        $providerCtx == null ? void 0 : $providerCtx.onClose();
      }
      $$invalidate(4, open = v);
    }
  });
  validate_store(ctx, "ctx");
  component_subscribe($$self, ctx, (value) => $$invalidate(10, $ctx = value));
  let openTimer = 0;
  let wasOpenDelayed = false;
  const handleOpen = () => {
    window.clearTimeout(openTimer);
    $$invalidate(7, wasOpenDelayed = false);
    ctx.update((p) => ({ ...p, open: true }));
  };
  const handleClose = () => {
    if (!isBrowser)
      return;
    window.clearTimeout(openTimer);
    ctx.update((p) => ({ ...p, open: false }));
  };
  const handleDelayedOpen = () => {
    if (!isBrowser)
      return;
    window.clearTimeout(openTimer);
    openTimer = window.setTimeout(
      () => {
        $$invalidate(7, wasOpenDelayed = true);
        ctx.update((p) => ({ ...p, open: true }));
      },
      delayDuration
    );
  };
  const onTriggerEnter = () => {
    if ($providerCtx == null ? void 0 : $providerCtx.isOpenDelayed) {
      handleDelayedOpen();
    } else {
      handleOpen();
    }
  };
  const onTriggerLeave = () => {
    if (disableHoverableContent) {
      handleClose();
    } else {
      window.clearTimeout(openTimer);
    }
  };
  onDestroy(() => {
    if (!isBrowser)
      return;
    window.clearTimeout(openTimer);
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("open" in $$new_props)
      $$invalidate(4, open = $$new_props.open);
    if ("delayDuration" in $$new_props)
      $$invalidate(5, delayDuration = $$new_props.delayDuration);
    if ("disableHoverableContent" in $$new_props)
      $$invalidate(6, disableHoverableContent = $$new_props.disableHoverableContent);
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    defaults: defaults15,
    getContext: getContext19,
    setContext: setContext19,
    getTooltipRootContext,
    Popper,
    generateId,
    isBrowser,
    reactiveContext,
    onDestroy,
    TOOLTIP_OPEN,
    getTooltipProviderContext,
    open,
    delayDuration,
    disableHoverableContent,
    use,
    providerCtx,
    ctx,
    openTimer,
    wasOpenDelayed,
    handleOpen,
    handleClose,
    handleDelayedOpen,
    onTriggerEnter,
    onTriggerLeave,
    stateAttribute,
    $providerCtx,
    $ctx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("open" in $$props)
      $$invalidate(4, open = $$new_props.open);
    if ("delayDuration" in $$props)
      $$invalidate(5, delayDuration = $$new_props.delayDuration);
    if ("disableHoverableContent" in $$props)
      $$invalidate(6, disableHoverableContent = $$new_props.disableHoverableContent);
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("openTimer" in $$props)
      openTimer = $$new_props.openTimer;
    if ("wasOpenDelayed" in $$props)
      $$invalidate(7, wasOpenDelayed = $$new_props.wasOpenDelayed);
    if ("stateAttribute" in $$props)
      $$invalidate(8, stateAttribute = $$new_props.stateAttribute);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*disableHoverableContent, $providerCtx*/
    576) {
      $:
        $$invalidate(6, disableHoverableContent = disableHoverableContent ?? ($providerCtx == null ? void 0 : $providerCtx.disableHoverableContent));
    }
    if ($$self.$$.dirty & /*delayDuration, $providerCtx*/
    544) {
      $:
        $$invalidate(5, delayDuration = delayDuration ?? ($providerCtx == null ? void 0 : $providerCtx.delayDuration));
    }
    if ($$self.$$.dirty & /*$ctx, wasOpenDelayed*/
    1152) {
      $:
        $$invalidate(8, stateAttribute = function() {
          if (!$ctx.open)
            return "closed";
          if (wasOpenDelayed)
            return "delayed-open";
          return "instant-open";
        }());
    }
    if ($$self.$$.dirty & /*open, stateAttribute, disableHoverableContent*/
    336) {
      $:
        ctx.update((prev2) => {
          return {
            ...prev2,
            open,
            stateAttribute,
            onTriggerEnter,
            onTriggerLeave,
            onOpen: handleOpen,
            onClose: handleClose,
            disableHoverableContent
          };
        });
    }
  };
  return [
    use,
    providerCtx,
    ctx,
    $$restProps,
    open,
    delayDuration,
    disableHoverableContent,
    wasOpenDelayed,
    stateAttribute,
    $providerCtx,
    $ctx,
    slots,
    $$scope
  ];
}
var Root20 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance66, create_fragment66, safe_not_equal, {
      open: 4,
      delayDuration: 5,
      disableHoverableContent: 6,
      use: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment66.name
    });
  }
  get open() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get delayDuration() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set delayDuration(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableHoverableContent() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableHoverableContent(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var root_default20 = Root20;

// node_modules/radix-svelte/dist/components/Tooltip/trigger.svelte
function create_default_slot23(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot23.name,
    type: "slot",
    source: `(24:0) <Popper.Anchor  as=\\"button\\"  aria-describedby={$ctx.open ? $ctx.contentId : undefined}  data-state={$ctx.stateAttribute}  bind:ref={$ctx.trigger}  on:pointermove  on:pointermove={(event) => {   if (event.pointerType === 'touch') return;   if (!hasPointerMoveOpened && !$providerCtx?.isPointerInTransit) {    $ctx.onTriggerEnter();    hasPointerMoveOpened = true;   }  }}  on:pointerleave  on:pointerleave={() => {   $ctx.onTriggerLeave();   hasPointerMoveOpened = false;  }}  on:pointerdown  on:pointerdown={() => {   if (!isBrowser) return;    isPointerDown = true;   document.addEventListener('pointerup', handlePointerUp, { once: true });  }}  on:focus  on:focus={() => {   if (isPointerDown) return;   $ctx.onOpen();  }}  on:blur  on:blur={() => {   $ctx.onClose();  }}  on:click  on:click={() => {   $ctx.onClose();  }}  use={[...(use ?? [])]}  {...$$restProps} >`,
    ctx
  });
  return block;
}
function create_fragment67(ctx) {
  let popper_anchor;
  let updating_ref;
  let current;
  const popper_anchor_spread_levels = [
    { as: "button" },
    {
      "aria-describedby": (
        /*$ctx*/
        ctx[3].open ? (
          /*$ctx*/
          ctx[3].contentId
        ) : void 0
      )
    },
    {
      "data-state": (
        /*$ctx*/
        ctx[3].stateAttribute
      )
    },
    { use: [.../*use*/
    ctx[0] ?? []] },
    /*$$restProps*/
    ctx[8]
  ];
  function popper_anchor_ref_binding(value) {
    ctx[10](value);
  }
  let popper_anchor_props = {
    $$slots: { default: [create_default_slot23] },
    $$scope: { ctx }
  };
  for (let i = 0; i < popper_anchor_spread_levels.length; i += 1) {
    popper_anchor_props = assign(popper_anchor_props, popper_anchor_spread_levels[i]);
  }
  if (
    /*$ctx*/
    ctx[3].trigger !== void 0
  ) {
    popper_anchor_props.ref = /*$ctx*/
    ctx[3].trigger;
  }
  popper_anchor = new Popper.Anchor({
    props: popper_anchor_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(popper_anchor, "ref", popper_anchor_ref_binding));
  popper_anchor.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[11]
  );
  popper_anchor.$on(
    "pointermove",
    /*pointermove_handler_1*/
    ctx[12]
  );
  popper_anchor.$on(
    "pointerleave",
    /*pointerleave_handler*/
    ctx[13]
  );
  popper_anchor.$on(
    "pointerleave",
    /*pointerleave_handler_1*/
    ctx[14]
  );
  popper_anchor.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[15]
  );
  popper_anchor.$on(
    "pointerdown",
    /*pointerdown_handler_1*/
    ctx[16]
  );
  popper_anchor.$on(
    "focus",
    /*focus_handler*/
    ctx[17]
  );
  popper_anchor.$on(
    "focus",
    /*focus_handler_1*/
    ctx[18]
  );
  popper_anchor.$on(
    "blur",
    /*blur_handler*/
    ctx[19]
  );
  popper_anchor.$on(
    "blur",
    /*blur_handler_1*/
    ctx[20]
  );
  popper_anchor.$on(
    "click",
    /*click_handler*/
    ctx[21]
  );
  popper_anchor.$on(
    "click",
    /*click_handler_1*/
    ctx[22]
  );
  const block = {
    c: function create() {
      create_component(popper_anchor.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(popper_anchor.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(popper_anchor, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const popper_anchor_changes = dirty & /*$ctx, undefined, use, $$restProps*/
      265 ? get_spread_update(popper_anchor_spread_levels, [
        popper_anchor_spread_levels[0],
        dirty & /*$ctx, undefined*/
        8 && {
          "aria-describedby": (
            /*$ctx*/
            ctx2[3].open ? (
              /*$ctx*/
              ctx2[3].contentId
            ) : void 0
          )
        },
        dirty & /*$ctx*/
        8 && {
          "data-state": (
            /*$ctx*/
            ctx2[3].stateAttribute
          )
        },
        dirty & /*use*/
        1 && { use: [.../*use*/
        ctx2[0] ?? []] },
        dirty & /*$$restProps*/
        256 && get_spread_object(
          /*$$restProps*/
          ctx2[8]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      8388608) {
        popper_anchor_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_ref && dirty & /*$ctx*/
      8) {
        updating_ref = true;
        popper_anchor_changes.ref = /*$ctx*/
        ctx2[3].trigger;
        add_flush_callback(() => updating_ref = false);
      }
      popper_anchor.$set(popper_anchor_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(popper_anchor.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(popper_anchor.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(popper_anchor, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment67.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance67($$self, $$props, $$invalidate) {
  const omit_props_names = ["use"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $ctx;
  let $providerCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Trigger", slots, ["default"]);
  let { use = [] } = $$props;
  const ctx = getTooltipRootContext();
  validate_store(ctx, "ctx");
  component_subscribe($$self, ctx, (value) => $$invalidate(3, $ctx = value));
  const providerCtx = getTooltipProviderContext();
  validate_store(providerCtx, "providerCtx");
  component_subscribe($$self, providerCtx, (value) => $$invalidate(4, $providerCtx = value));
  let isPointerDown = false;
  let hasPointerMoveOpened = false;
  const handlePointerUp = () => {
    $$invalidate(1, isPointerDown = false);
  };
  onDestroy(() => {
    if (!isBrowser)
      return;
    document.removeEventListener("pointerup", handlePointerUp);
  });
  function popper_anchor_ref_binding(value) {
    if ($$self.$$.not_equal($ctx.trigger, value)) {
      $ctx.trigger = value;
      ctx.set($ctx);
    }
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  const pointermove_handler_1 = (event) => {
    if (event.pointerType === "touch")
      return;
    if (!hasPointerMoveOpened && !($providerCtx == null ? void 0 : $providerCtx.isPointerInTransit)) {
      $ctx.onTriggerEnter();
      $$invalidate(2, hasPointerMoveOpened = true);
    }
  };
  function pointerleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  const pointerleave_handler_1 = () => {
    $ctx.onTriggerLeave();
    $$invalidate(2, hasPointerMoveOpened = false);
  };
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  const pointerdown_handler_1 = () => {
    if (!isBrowser)
      return;
    $$invalidate(1, isPointerDown = true);
    document.addEventListener("pointerup", handlePointerUp, { once: true });
  };
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  const focus_handler_1 = () => {
    if (isPointerDown)
      return;
    $ctx.onOpen();
  };
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  const blur_handler_1 = () => {
    $ctx.onClose();
  };
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler_1 = () => {
    $ctx.onClose();
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(23, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Popper,
    isBrowser,
    onDestroy,
    getTooltipProviderContext,
    getTooltipRootContext,
    use,
    ctx,
    providerCtx,
    isPointerDown,
    hasPointerMoveOpened,
    handlePointerUp,
    $ctx,
    $providerCtx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("isPointerDown" in $$props)
      $$invalidate(1, isPointerDown = $$new_props.isPointerDown);
    if ("hasPointerMoveOpened" in $$props)
      $$invalidate(2, hasPointerMoveOpened = $$new_props.hasPointerMoveOpened);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    isPointerDown,
    hasPointerMoveOpened,
    $ctx,
    $providerCtx,
    ctx,
    providerCtx,
    handlePointerUp,
    $$restProps,
    slots,
    popper_anchor_ref_binding,
    pointermove_handler,
    pointermove_handler_1,
    pointerleave_handler,
    pointerleave_handler_1,
    pointerdown_handler,
    pointerdown_handler_1,
    focus_handler,
    focus_handler_1,
    blur_handler,
    blur_handler_1,
    click_handler,
    click_handler_1,
    $$scope
  ];
}
var Trigger7 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance67, create_fragment67, safe_not_equal, { use: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Trigger",
      options,
      id: create_fragment67.name
    });
  }
  get use() {
    throw new Error("<Trigger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Trigger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var trigger_default7 = Trigger7;

// node_modules/radix-svelte/dist/components/Tooltip/portal.svelte
function create_if_block12(ctx) {
  let portal2;
  let current;
  const portal_spread_levels = [
    { target: (
      /*container*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let portal_props = {
    $$slots: { default: [create_default_slot24] },
    $$scope: { ctx }
  };
  for (let i = 0; i < portal_spread_levels.length; i += 1) {
    portal_props = assign(portal_props, portal_spread_levels[i]);
  }
  portal2 = new Portal_default({ props: portal_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(portal2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(portal2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(portal2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const portal_changes = dirty & /*container, $$restProps*/
      9 ? get_spread_update(portal_spread_levels, [
        dirty & /*container*/
        1 && { target: (
          /*container*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      32) {
        portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portal2.$set(portal_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(portal2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(portal2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(portal2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block12.name,
    type: "if",
    source: "(10:0) {#if $ctx.open}",
    ctx
  });
  return block;
}
function create_default_slot24(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot24.name,
    type: "slot",
    source: "(11:1) <Portal target={container} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment68(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$ctx*/
    ctx[1].open && create_if_block12(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$ctx*/
        ctx2[1].open
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$ctx*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment68.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance68($$self, $$props, $$invalidate) {
  const omit_props_names = ["container"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $ctx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Portal", slots, ["default"]);
  let { container = "body" } = $$props;
  const ctx = getTooltipRootContext();
  validate_store(ctx, "ctx");
  component_subscribe($$self, ctx, (value) => $$invalidate(1, $ctx = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("container" in $$new_props)
      $$invalidate(0, container = $$new_props.container);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Portal: Portal_default,
    getTooltipRootContext,
    container,
    ctx,
    $ctx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("container" in $$props)
      $$invalidate(0, container = $$new_props.container);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [container, $ctx, ctx, $$restProps, slots, $$scope];
}
var Portal_13 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance68, create_fragment68, safe_not_equal, { container: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Portal_1",
      options,
      id: create_fragment68.name
    });
  }
  get container() {
    throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var portal_default4 = Portal_13;

// node_modules/radix-svelte/dist/internal/stores/callAndCleanup.js
var createCallAndCleanup = () => ({
  subscribe(runner) {
    let cleanup = null;
    runner((cb) => {
      cleanup == null ? void 0 : cleanup();
      cleanup = cb() ?? null;
    });
    return () => {
      cleanup == null ? void 0 : cleanup();
      cleanup = null;
    };
  }
});

// node_modules/radix-svelte/dist/components/Tooltip/internal/content-impl.svelte
function create_default_slot25(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot25.name,
    type: "slot",
    source: "(38:0) <Popper.Content  {...$$restProps}  use={[   ...(use ?? []),   [    dismissable,    {     onPointerDownOutside,     onEscapeKeyDown,     onDismiss: () => {      $rootCtx.onClose();     },    },   ],  ]}  data-state={$rootCtx.stateAttribute}  bind:ref >",
    ctx
  });
  return block;
}
function create_fragment69(ctx) {
  let popper_content;
  let updating_ref;
  let current;
  const popper_content_spread_levels = [
    /*$$restProps*/
    ctx[6],
    {
      use: [
        .../*use*/
        ctx[1] ?? [],
        [
          dismissable,
          {
            onPointerDownOutside: (
              /*onPointerDownOutside*/
              ctx[4]
            ),
            onEscapeKeyDown: (
              /*onEscapeKeyDown*/
              ctx[5]
            ),
            onDismiss: (
              /*func*/
              ctx[8]
            )
          }
        ]
      ]
    },
    {
      "data-state": (
        /*$rootCtx*/
        ctx[2].stateAttribute
      )
    }
  ];
  function popper_content_ref_binding(value) {
    ctx[9](value);
  }
  let popper_content_props = {
    $$slots: { default: [create_default_slot25] },
    $$scope: { ctx }
  };
  for (let i = 0; i < popper_content_spread_levels.length; i += 1) {
    popper_content_props = assign(popper_content_props, popper_content_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[0] !== void 0
  ) {
    popper_content_props.ref = /*ref*/
    ctx[0];
  }
  popper_content = new Popper.Content({
    props: popper_content_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(popper_content, "ref", popper_content_ref_binding));
  const block = {
    c: function create() {
      create_component(popper_content.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(popper_content.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(popper_content, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const popper_content_changes = dirty & /*$$restProps, use, dismissable, onPointerDownOutside, onEscapeKeyDown, $rootCtx*/
      118 ? get_spread_update(popper_content_spread_levels, [
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx2[6]
        ),
        dirty & /*use, dismissable, onPointerDownOutside, onEscapeKeyDown, $rootCtx*/
        54 && {
          use: [
            .../*use*/
            ctx2[1] ?? [],
            [
              dismissable,
              {
                onPointerDownOutside: (
                  /*onPointerDownOutside*/
                  ctx2[4]
                ),
                onEscapeKeyDown: (
                  /*onEscapeKeyDown*/
                  ctx2[5]
                ),
                onDismiss: (
                  /*func*/
                  ctx2[8]
                )
              }
            ]
          ]
        },
        dirty & /*$rootCtx*/
        4 && {
          "data-state": (
            /*$rootCtx*/
            ctx2[2].stateAttribute
          )
        }
      ]) : {};
      if (dirty & /*$$scope*/
      1024) {
        popper_content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_ref && dirty & /*ref*/
      1) {
        updating_ref = true;
        popper_content_changes.ref = /*ref*/
        ctx2[0];
        add_flush_callback(() => updating_ref = false);
      }
      popper_content.$set(popper_content_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(popper_content.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(popper_content.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(popper_content, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment69.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance69($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Content_impl", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { use = [] } = $$props;
  let { ref = void 0 } = $$props;
  const rootCtx = getTooltipRootContext();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value) => $$invalidate(2, $rootCtx = value));
  onMount(() => {
    document.addEventListener(TOOLTIP_OPEN, $rootCtx.onClose);
    return () => {
      document.removeEventListener(TOOLTIP_OPEN, $rootCtx.onClose);
    };
  });
  const handleScroll = (event) => {
    const target = event.target;
    if (target == null ? void 0 : target.contains($rootCtx.trigger)) {
      $rootCtx.onClose();
    }
  };
  const onPointerDownOutside = (event) => {
    dispatch("pointerDownOutside", event.detail);
  };
  const onEscapeKeyDown = (event) => {
    dispatch("escapeKeyDown", event.detail);
  };
  const func = () => {
    $rootCtx.onClose();
  };
  function popper_content_ref_binding(value) {
    ref = value;
    $$invalidate(0, ref);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    dismissable,
    Popper,
    createEventDispatcher,
    onMount,
    TOOLTIP_OPEN,
    getTooltipRootContext,
    dispatch,
    use,
    ref,
    rootCtx,
    handleScroll,
    onPointerDownOutside,
    onEscapeKeyDown,
    $rootCtx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$rootCtx*/
    4) {
      $: {
        window.removeEventListener("scroll", handleScroll, { capture: true });
        if ($rootCtx.trigger) {
          window.addEventListener("scroll", handleScroll, { capture: true });
        }
      }
    }
  };
  return [
    ref,
    use,
    $rootCtx,
    rootCtx,
    onPointerDownOutside,
    onEscapeKeyDown,
    $$restProps,
    slots,
    func,
    popper_content_ref_binding,
    $$scope
  ];
}
var Content_impl = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance69, create_fragment69, safe_not_equal, { use: 1, ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Content_impl",
      options,
      id: create_fragment69.name
    });
  }
  get use() {
    throw new Error("<Content_impl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Content_impl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Content_impl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Content_impl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var content_impl_default = Content_impl;

// node_modules/radix-svelte/dist/components/Tooltip/internal/content-hoverable.svelte
function create_default_slot26(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot26.name,
    type: "slot",
    source: "(176:0) <ContentImpl bind:ref {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment70(ctx) {
  let contentimpl;
  let updating_ref;
  let current;
  const contentimpl_spread_levels = [
    /*$$restProps*/
    ctx[4]
  ];
  function contentimpl_ref_binding(value) {
    ctx[10](value);
  }
  let contentimpl_props = {
    $$slots: { default: [create_default_slot26] },
    $$scope: { ctx }
  };
  for (let i = 0; i < contentimpl_spread_levels.length; i += 1) {
    contentimpl_props = assign(contentimpl_props, contentimpl_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[0] !== void 0
  ) {
    contentimpl_props.ref = /*ref*/
    ctx[0];
  }
  contentimpl = new content_impl_default({ props: contentimpl_props, $$inline: true });
  binding_callbacks.push(() => bind(contentimpl, "ref", contentimpl_ref_binding));
  const block = {
    c: function create() {
      create_component(contentimpl.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(contentimpl.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(contentimpl, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const contentimpl_changes = dirty & /*$$restProps*/
      16 ? get_spread_update(contentimpl_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[4]
      )]) : {};
      if (dirty & /*$$scope*/
      2048) {
        contentimpl_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_ref && dirty & /*ref*/
      1) {
        updating_ref = true;
        contentimpl_changes.ref = /*ref*/
        ctx2[0];
        add_flush_callback(() => updating_ref = false);
      }
      contentimpl.$set(contentimpl_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(contentimpl.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(contentimpl.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(contentimpl, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment70.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      return null;
  }
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a, b) => {
    if (a.x < b.x)
      return -1;
    else if (a.x > b.x)
      return 1;
    else if (a.y < b.y)
      return -1;
    else if (a.y > b.y)
      return 1;
    else
      return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r = upperHull[upperHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
        upperHull.pop();
      else
        break;
    }
    upperHull.push(p);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r = lowerHull[lowerHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
        lowerHull.pop();
      else
        break;
    }
    lowerHull.push(p);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
function instance70($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let $pgaEffect;
  let $handlerEffect;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Content_hoverable", slots, ["default"]);
  const providerCtx = getTooltipProviderContext();
  const rootCtx = getTooltipRootContext();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value) => $$invalidate(6, $rootCtx = value));
  let ref = null;
  let pointerGraceArea = null;
  const handleRemoveGraceArea = () => {
    $$invalidate(5, pointerGraceArea = null);
    providerCtx == null ? void 0 : providerCtx.update((prev2) => {
      return { ...prev2, isPointerInTransit: false };
    });
  };
  const handleCreateGraceArea = (event, hoverTarget) => {
    const currentTarget = event.currentTarget;
    const exitPoint = { x: event.clientX, y: event.clientY };
    const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
    const bleed = exitSide === "right" || exitSide === "bottom" ? -5 : 5;
    const isXAxis = exitSide === "right" || exitSide === "left";
    const startPoint = isXAxis ? {
      x: event.clientX + bleed,
      y: event.clientY
    } : {
      x: event.clientX,
      y: event.clientY + bleed
    };
    const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
    const graceArea = getHull([startPoint, ...hoverTargetPoints]);
    $$invalidate(5, pointerGraceArea = graceArea);
    providerCtx == null ? void 0 : providerCtx.update((prev2) => {
      return { ...prev2, isPointerInTransit: true };
    });
  };
  const handlerEffect = createCallAndCleanup();
  validate_store(handlerEffect, "handlerEffect");
  component_subscribe($$self, handlerEffect, (value) => $$invalidate(8, $handlerEffect = value));
  const pgaEffect = createCallAndCleanup();
  validate_store(pgaEffect, "pgaEffect");
  component_subscribe($$self, pgaEffect, (value) => $$invalidate(7, $pgaEffect = value));
  onDestroy(() => {
    handleRemoveGraceArea();
  });
  function contentimpl_ref_binding(value) {
    ref = value;
    $$invalidate(0, ref);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    getTooltipProviderContext,
    getTooltipRootContext,
    getExitSideFromRect,
    getPointsFromRect,
    isPointInPolygon,
    getHull,
    getHullPresorted,
    createCallAndCleanup,
    ContentImpl: content_impl_default,
    providerCtx,
    rootCtx,
    ref,
    pointerGraceArea,
    handleRemoveGraceArea,
    handleCreateGraceArea,
    handlerEffect,
    pgaEffect,
    $rootCtx,
    $pgaEffect,
    $handlerEffect
  });
  $$self.$inject_state = ($$new_props) => {
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("pointerGraceArea" in $$props)
      $$invalidate(5, pointerGraceArea = $$new_props.pointerGraceArea);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$handlerEffect, ref, $rootCtx*/
    321) {
      $:
        $handlerEffect(() => {
          if (ref && $rootCtx.trigger) {
            const trigger = $rootCtx.trigger;
            const content = ref;
            const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
            const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
            $rootCtx.trigger.addEventListener("pointerleave", handleTriggerLeave);
            ref.addEventListener("pointerleave", handleContentLeave);
            return () => {
              var _a;
              (_a = $rootCtx.trigger) == null ? void 0 : _a.removeEventListener("pointerleave", handleTriggerLeave);
              ref == null ? void 0 : ref.removeEventListener("pointerleave", handleContentLeave);
            };
          }
        });
    }
    if ($$self.$$.dirty & /*$pgaEffect, pointerGraceArea, $rootCtx, ref*/
    225) {
      $:
        $pgaEffect(() => {
          if (pointerGraceArea) {
            const pga = pointerGraceArea;
            const handleTrackPointerGrace = (event) => {
              var _a;
              const target = event.target;
              const pointerPosition = { x: event.clientX, y: event.clientY };
              const hasEnteredTarget = ((_a = $rootCtx.trigger) == null ? void 0 : _a.contains(target)) || (ref == null ? void 0 : ref.contains(target));
              const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pga);
              if (hasEnteredTarget) {
                handleRemoveGraceArea();
              } else if (isPointerOutsideGraceArea) {
                handleRemoveGraceArea();
                $rootCtx.onClose();
              }
            };
            document.addEventListener("pointermove", handleTrackPointerGrace);
            return () => {
              document.removeEventListener("pointermove", handleTrackPointerGrace);
            };
          }
        });
    }
  };
  return [
    ref,
    rootCtx,
    handlerEffect,
    pgaEffect,
    $$restProps,
    pointerGraceArea,
    $rootCtx,
    $pgaEffect,
    $handlerEffect,
    slots,
    contentimpl_ref_binding,
    $$scope
  ];
}
var Content_hoverable = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance70, create_fragment70, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Content_hoverable",
      options,
      id: create_fragment70.name
    });
  }
};
var content_hoverable_default = Content_hoverable;

// node_modules/radix-svelte/dist/components/Tooltip/content.svelte
function create_else_block2(ctx) {
  let contenthoverable;
  let current;
  const contenthoverable_spread_levels = [
    { side: (
      /*side*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let contenthoverable_props = {
    $$slots: { default: [create_default_slot_1] },
    $$scope: { ctx }
  };
  for (let i = 0; i < contenthoverable_spread_levels.length; i += 1) {
    contenthoverable_props = assign(contenthoverable_props, contenthoverable_spread_levels[i]);
  }
  contenthoverable = new content_hoverable_default({
    props: contenthoverable_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(contenthoverable.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(contenthoverable.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(contenthoverable, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const contenthoverable_changes = dirty & /*side, $$restProps*/
      9 ? get_spread_update(contenthoverable_spread_levels, [
        dirty & /*side*/
        1 && { side: (
          /*side*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      32) {
        contenthoverable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contenthoverable.$set(contenthoverable_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(contenthoverable.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(contenthoverable.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(contenthoverable, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(14:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block13(ctx) {
  let contentimpl;
  let current;
  const contentimpl_spread_levels = [
    { side: (
      /*side*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let contentimpl_props = {
    $$slots: { default: [create_default_slot27] },
    $$scope: { ctx }
  };
  for (let i = 0; i < contentimpl_spread_levels.length; i += 1) {
    contentimpl_props = assign(contentimpl_props, contentimpl_spread_levels[i]);
  }
  contentimpl = new content_impl_default({ props: contentimpl_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(contentimpl.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(contentimpl.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(contentimpl, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const contentimpl_changes = dirty & /*side, $$restProps*/
      9 ? get_spread_update(contentimpl_spread_levels, [
        dirty & /*side*/
        1 && { side: (
          /*side*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      32) {
        contentimpl_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contentimpl.$set(contentimpl_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(contentimpl.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(contentimpl.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(contentimpl, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(10:0) {#if $rootCtx.disableHoverableContent}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(15:1) <ContentHoverable {side} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_default_slot27(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot27.name,
    type: "slot",
    source: "(11:1) <ContentImpl {side} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment71(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block13, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$rootCtx*/
      ctx2[1].disableHoverableContent
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment71.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance71($$self, $$props, $$invalidate) {
  const omit_props_names = ["side"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rootCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Content", slots, ["default"]);
  let { side = "top" } = $$props;
  const rootCtx = getTooltipRootContext();
  validate_store(rootCtx, "rootCtx");
  component_subscribe($$self, rootCtx, (value) => $$invalidate(1, $rootCtx = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("side" in $$new_props)
      $$invalidate(0, side = $$new_props.side);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getTooltipRootContext,
    ContentHoverable: content_hoverable_default,
    ContentImpl: content_impl_default,
    side,
    rootCtx,
    $rootCtx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("side" in $$props)
      $$invalidate(0, side = $$new_props.side);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [side, $rootCtx, rootCtx, $$restProps, slots, $$scope];
}
var Content8 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance71, create_fragment71, safe_not_equal, { side: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Content",
      options,
      id: create_fragment71.name
    });
  }
  get side() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set side(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var content_default8 = Content8;

// node_modules/radix-svelte/dist/components/Tooltip/index.js
var Tooltip = {
  Provider: provider_default,
  Root: root_default20,
  Trigger: trigger_default7,
  Portal: portal_default4,
  Content: content_default8,
  Arrow: arrow_default
};
export {
  Accordion,
  AlertDialog,
  AspectRatio,
  Avatar,
  Checkbox,
  Collapsible,
  Dialog,
  HoverCard,
  Label,
  Progress,
  RadioGroup,
  Separator,
  Slider,
  Switch,
  Tabs,
  Toggle,
  ToggleGroup,
  Tooltip
};
//# sourceMappingURL=radix-svelte.js.map
